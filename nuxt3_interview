✅ Basic Level (Beginner-Friendly)
1. What is Nuxt 3? How is it different from Nuxt 2?
Answer: Nuxt 3 is a full-stack framework built on Vue 3, offering modern web development capabilities with improved performance and developer experience.

Key Differences from Nuxt 2:

Vue 3 Foundation: Built on Vue 3 with Composition API support
Nitro Engine: New server engine for universal deployment
TypeScript First: Native TypeScript support out of the box
Auto-imports: Automatic importing of components, composables, and utilities
Smaller Bundle: Better tree-shaking and optimized builds
Vite Support: Lightning-fast development with Vite
Edge-side Rendering: Support for edge deployment targets
2. What are the key features of Nuxt 3?
Answer:

Auto-imports: Components, composables, and Vue APIs are automatically imported
File-based Routing: Pages created based on file structure
Universal Rendering: SSR, SSG, SPA modes supported
Server-side API: Built-in API routes with /server/api/
Data Fetching: Built-in composables like useFetch() and useAsyncData()
TypeScript: First-class TypeScript support
Nitro Engine: Universal deployment to 15+ platforms
Hybrid Rendering: Mix SSR and SSG in the same app
3. What is the purpose of pages/ directory in Nuxt 3?
Answer: The pages/ directory creates file-based routing automatically:

Vue
<!-- pages/index.vue → / -->
<template>
  <div>Home Page</div>
</template>

<!-- pages/about.vue → /about -->
<template>
  <div>About Page</div>
</template>

<!-- pages/products/[id].vue → /products/:id -->
<template>
  <div>Product: {{ $route.params.id }}</div>
</template>
4. How do you define a dynamic route in Nuxt 3?
Answer: Use square brackets [] in filename:

Vue
<!-- pages/users/[id].vue -->
<template>
  <div>
    <h1>User Profile</h1>
    <p>User ID: {{ $route.params.id }}</p>
  </div>
</template>

<script setup>
// Access route parameters
const route = useRoute()
const userId = route.params.id

// Or using computed
const userId = computed(() => route.params.id)
</script>
Catch-all routes:

Vue
<!-- pages/[...slug].vue matches /a, /a/b, /a/b/c -->
<template>
  <div>{{ $route.params.slug }}</div>
</template>
5. How is layouts/ used in Nuxt 3?
Answer: Layouts define common UI structure:

Vue
<!-- layouts/default.vue -->
<template>
  <div>
    <header>
      <nav>Navigation</nav>
    </header>
    <main>
      <slot />
    </main>
    <footer>Footer</footer>
  </div>
</template>
Using layouts in pages:

Vue
<!-- pages/about.vue -->
<template>
  <div>About content</div>
</template>

<script setup>
// Use specific layout
definePageMeta({
  layout: 'custom'
})
</script>
6. What is a plugin in Nuxt 3?
Answer: Plugins extend Vue app functionality and run before mounting:

TypeScript
// plugins/vue-toastification.client.ts
import Toast from "vue-toastification"

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.use(Toast)
})
7. What is the difference between useState() and ref()?
Answer:

Feature	useState()	ref()
Scope	Global reactive state	Component-scoped
SSR	Synced between server/client	Component instance only
Persistence	Persists across navigation	Resets on navigation
Usage	Shared state management	Local component state
TypeScript
// useState - Global state
const counter = useState('counter', () => 0)

// ref - Component state
const localCount = ref(0)
8. How do you fetch data in Nuxt 3 using useFetch()?
Answer:

TypeScript
<script setup>
// Basic usage
const { data, pending, error } = await useFetch('/api/users')

// With options
const { data: posts } = await useFetch('/api/posts', {
  query: { limit: 10 },
  headers: { 'Authorization': 'Bearer token' }
})

// With transformation
const { data } = await useFetch('/api/users', {
  transform: (data: any[]) => data.map(user => ({ ...user, fullName: `${user.first} ${user.last}` }))
})
</script>
9. What is defineNuxtPlugin() used for?
Answer: defineNuxtPlugin() creates plugins that extend the Nuxt app:

TypeScript
// plugins/api.ts
export default defineNuxtPlugin((nuxtApp) => {
  const api = {
    get: (url: string) => $fetch(url),
    post: (url: string, data: any) => $fetch(url, { method: 'POST', body: data })
  }
  
  return {
    provide: {
      api
    }
  }
})

// Usage in component
const { $api } = useNuxtApp()
const users = await $api.get('/api/users')
10. How do you manage global CSS in Nuxt 3?
Answer:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  css: [
    '~/assets/css/main.css',
    '~/assets/scss/global.scss'
  ],
  
  // Or using Tailwind
  modules: ['@nuxtjs/tailwindcss']
})
⚙️ Intermediate Level
11. What is the purpose of nuxt.config.ts? What are some common options?
Answer: nuxt.config.ts is the main configuration file:

TypeScript
export default defineNuxtConfig({
  // Development
  devtools: { enabled: true },
  
  // Rendering
  ssr: true,
  
  // Modules
  modules: [
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt'
  ],
  
  // Runtime config
  runtimeConfig: {
    apiSecret: process.env.API_SECRET,
    public: {
      apiBase: process.env.API_BASE_URL
    }
  },
  
  // App config
  app: {
    head: {
      title: 'My App',
      meta: [
        { name: 'description', content: 'My amazing app' }
      ]
    }
  },
  
  // Build
  build: {
    transpile: ['some-library']
  }
})
12. Explain how Nuxt 3 uses Nitro for server-side rendering.
Answer: Nitro is Nuxt 3's server engine that provides:

Universal Deployment: Deploy to 15+ platforms (Vercel, Netlify, AWS, etc.)
Auto-optimization: Automatic code splitting and tree shaking
Edge Support: Deploy to edge networks for better performance
API Routes: Built-in API handling with /server/api/
Middleware: Server middleware support
Storage: Built-in storage layer
TypeScript
// server/api/users.get.ts
export default defineEventHandler(async (event) => {
  // Nitro automatically handles this API route
  return { users: await getUsers() }
})
13. How do you add middleware in Nuxt 3? Give an example.
Answer: Route Middleware:

TypeScript
// middleware/auth.ts
export default defineNuxtRouteMiddleware((to, from) => {
  const user = useState('user')
  
  if (!user.value) {
    return navigateTo('/login')
  }
})
Global Middleware:

TypeScript
// middleware/auth.global.ts
export default defineNuxtRouteMiddleware((to) => {
  console.log('Navigating to:', to.path)
})
Using in pages:

Vue
<script setup>
definePageMeta({
  middleware: 'auth'
})
</script>
14. What is the use of composables in Nuxt 3? How do you create one?
Answer: Composables are reusable stateful logic functions:

TypeScript
// composables/useCounter.ts
export const useCounter = () => {
  const count = useState('counter', () => 0)
  
  const increment = () => count.value++
  const decrement = () => count.value--
  const reset = () => count.value = 0
  
  return {
    count: readonly(count),
    increment,
    decrement,
    reset
  }
}

// Usage in component
<script setup>
const { count, increment, decrement } = useCounter()
</script>
15. What is the difference between useAsyncData() and useFetch()?
Answer:

Feature	useAsyncData()	useFetch()
Purpose	Generic async data fetching	HTTP requests specifically
Built-in	Manual fetch function	Built-in $fetch
Flexibility	More flexible, any async operation	HTTP-focused
Usage	Custom data sources	API endpoints
TypeScript
// useAsyncData - More flexible
const { data } = await useAsyncData('users', () => {
  // Can be any async operation
  return myCustomFetchFunction('/api/users')
})

// useFetch - HTTP focused
const { data } = await useFetch('/api/users')
🧠 Advanced Level
16. How does Nuxt 3 handle SSR and SSG?
Answer: SSR (Server-Side Rendering):

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  ssr: true, // Default
  nitro: {
    prerender: {
      routes: ['/sitemap.xml']
    }
  }
})
SSG (Static Site Generation):

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    prerender: {
      routes: ['/about', '/contact']
    }
  }
})

// Or generate all routes
npm run generate
Hybrid Rendering:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  routeRules: {
    '/': { prerender: true }, // SSG
    '/admin/**': { ssr: false }, // SPA
    '/api/**': { cors: true },
    '/blog/**': { isr: 60 } // ISR
  }
})
17. How would you implement authentication in Nuxt 3?
Answer:

TypeScript
// composables/useAuth.ts
export const useAuth = () => {
  const user = useState('auth.user', () => null)
  
  const login = async (credentials: LoginCredentials) => {
    const { data } = await $fetch('/api/login', {
      method: 'POST',
      body: credentials
    })
    
    user.value = data.user
    await navigateTo('/dashboard')
  }
  
  const logout = async () => {
    await $fetch('/api/logout', { method: 'POST' })
    user.value = null
    await navigateTo('/login')
  }
  
  return {
    user: readonly(user),
    login,
    logout
  }
}

// middleware/auth.ts
export default defineNuxtRouteMiddleware(() => {
  const { user } = useAuth()
  
  if (!user.value) {
    return navigateTo('/login')
  }
})
18. How do you use runtime config in Nuxt 3?
Answer:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  runtimeConfig: {
    // Private keys (server-side only)
    apiSecret: process.env.API_SECRET,
    
    // Public keys (exposed to client)
    public: {
      apiBase: process.env.API_BASE_URL || '/api'
    }
  }
})

// Usage in components/composables
<script setup>
const config = useRuntimeConfig()

// Server-side only
const secret = config.apiSecret

// Available on both server and client
const apiBase = config.public.apiBase
</script>
19. How do you handle error pages in Nuxt 3?
Answer:

Vue
<!-- error.vue in root directory -->
<template>
  <div class="error-page">
    <h1>{{ error.statusCode }}</h1>
    <p>{{ error.statusMessage }}</p>
    <button @click="handleError">
      {{ error.statusCode === 404 ? 'Go Home' : 'Try Again' }}
    </button>
  </div>
</template>

<script setup>
interface NuxtError {
  statusCode: number
  statusMessage: string
}

defineProps<{
  error: NuxtError
}>()

const handleError = () => {
  if (error.statusCode === 404) {
    navigateTo('/')
  } else {
    clearError({ redirect: '/' })
  }
}
</script>
🚀 Deployment & DevOps
20. How do you deploy a Nuxt 3 app on Vercel?
Answer:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    preset: 'vercel-edge' // or 'vercel'
  }
})
JSON
// vercel.json
{
  "builds": [
    {
      "src": "nuxt.config.ts",
      "use": "@nuxtjs/vercel-builder"
    }
  ]
}
Environment Variables:

bash
# .env
API_SECRET=your-secret-key
PUBLIC_API_BASE=https://api.example.com
21. How do you implement Docker deployment?
Answer:

Dockerfile
# Dockerfile
FROM node:18-alpine

WORKDIR /app

COPY package*.json ./
RUN npm ci --only=production && npm cache clean --force

COPY . .
RUN npm run build

EXPOSE 3000

CMD ["node", ".output/server/index.mjs"]
YAML
# docker-compose.yml
version: '3.8'
services:
  nuxt-app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - API_SECRET=${API_SECRET}
🔌 Ecosystem & Tooling
22. How do you integrate Tailwind CSS with Nuxt 3?
Answer:

bash
npm install @nuxtjs/tailwindcss
TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: ['@nuxtjs/tailwindcss'],
  
  tailwindcss: {
    cssPath: '~/assets/css/tailwind.css',
    configPath: 'tailwind.config.js'
  }
})
CSS
/* assets/css/tailwind.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
23. How do you implement Pinia state management?
Answer:

bash
npm install @pinia/nuxt pinia
TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: ['@pinia/nuxt']
})

// stores/auth.ts
export const useAuthStore = defineStore('auth', () => {
  const user = ref(null)
  const isLoggedIn = computed(() => !!user.value)
  
  const login = async (credentials) => {
    const response = await $fetch('/api/login', {
      method: 'POST',
      body: credentials
    })
    user.value = response.user
  }
  
  return {
    user,
    isLoggedIn,
    login
  }
})

// Usage in component
<script setup>
const authStore = useAuthStore()
const { user, isLoggedIn } = storeToRefs(authStore)
</script>
🧪 Testing & Quality
24. How do you test a Nuxt 3 application?
Answer:

TypeScript
// vitest.config.ts
import { defineConfig } from 'vitest/config'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  test: {
    environment: 'nuxt'
  }
})

// tests/components/Button.test.ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import Button from '~/components/Button.vue'

describe('Button', () => {
  it('renders correctly', () => {
    const wrapper = mount(Button, {
      props: { label: 'Click me' }
    })
    
    expect(wrapper.text()).toContain('Click me')
  })
})
25. How do you implement internationalization (i18n)?
Answer:

bash
npm install @nuxtjs/i18n
TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: ['@nuxtjs/i18n'],
  
  i18n: {
    locales: [
      { code: 'en', name: 'English' },
      { code: 'es', name: 'Español' }
    ],
    defaultLocale: 'en',
    vueI18n: './i18n.config.ts'
  }
})

// i18n.config.ts
export default defineI18nConfig(() => ({
  legacy: false,
  locale: 'en',
  messages: {
    en: {
      welcome: 'Welcome',
      hello: 'Hello {name}'
    },
    es: {
      welcome: 'Bienvenido',
      hello: 'Hola {name}'
    }
  }
}))
This comprehensive guide covers the essential Nuxt 3 concepts with practical examples that demonstrate real-world usage patterns. Each answer includes code examples and explanations that would be valuable in both interview settings and actual development work.

You said: no , give me all questions answer
no , give me all questions answer based on you have given to me
Copilot said: # 🚀 Complete Nuxt 3 Interview Questions
🚀 Complete Nuxt 3 Interview Questions & Detailed Answers
Here are all 120 interview questions with comprehensive answers:

✅ Basic Level (Beginner-Friendly)
1. What is Nuxt 3? How is it different from Nuxt 2?
Answer: Nuxt 3 is a full-stack framework built on Vue 3 that provides an intuitive and extendable way to create type-safe, performant, and production-grade full-stack web apps and websites with Vue.js.

Key Differences from Nuxt 2:

Vue 3 Foundation: Built on Vue 3 with Composition API, better performance, and smaller bundle size
Nitro Engine: New server engine replacing Connect/Express, supporting 15+ deployment targets
TypeScript First: Native TypeScript support without additional configuration
Auto-imports: Automatic importing of components, composables, and Vue APIs
Vite Support: Lightning-fast development with Vite as default bundler
Better Tree-shaking: Smaller production bundles
Edge-side Rendering: Support for edge deployment and serverless functions
Hybrid Rendering: Mix different rendering modes per route
2. What are the key features of Nuxt 3?
Answer:

Auto-imports: Components, composables, and Vue APIs are automatically imported
File-based Routing: Automatic route generation based on file structure in pages/
Universal Rendering: SSR, SSG, SPA, and hybrid rendering modes
Server Engine (Nitro): Universal deployment to 15+ platforms
Data Fetching: Built-in composables like useFetch(), useAsyncData(), and $fetch
TypeScript: First-class TypeScript support with zero configuration
Code Splitting: Automatic code splitting and lazy loading
SEO Optimization: Built-in SEO features and meta tag management
Development Tools: Enhanced DevTools for debugging and development
3. What is the purpose of pages/ directory in Nuxt 3?
Answer: The pages/ directory creates file-based routing automatically. Each Vue file becomes a route:

Vue
<!-- pages/index.vue → / -->
<template>
  <div>
    <h1>Home Page</h1>
    <p>Welcome to our website!</p>
  </div>
</template>

<!-- pages/about.vue → /about -->
<template>
  <div>
    <h1>About Us</h1>
    <p>Learn more about our company</p>
  </div>
</template>

<!-- pages/blog/index.vue → /blog -->
<template>
  <div>
    <h1>Blog Posts</h1>
  </div>
</template>

<!-- pages/blog/[slug].vue → /blog/:slug -->
<template>
  <div>
    <h1>{{ post.title }}</h1>
    <p>{{ post.content }}</p>
  </div>
</template>

<script setup>
const route = useRoute()
const { data: post } = await useFetch(`/api/posts/${route.params.slug}`)
</script>
4. How do you define a dynamic route in Nuxt 3?
Answer: Use square brackets [] in the filename to create dynamic routes:

Vue
<!-- pages/users/[id].vue → /users/:id -->
<template>
  <div>
    <h1>User Profile</h1>
    <p>User ID: {{ $route.params.id }}</p>
    <div v-if="pending">Loading...</div>
    <div v-else-if="user">
      <h2>{{ user.name }}</h2>
      <p>{{ user.email }}</p>
    </div>
  </div>
</template>

<script setup>
const route = useRoute()
const { data: user, pending } = await useFetch(`/api/users/${route.params.id}`)

// Validate route parameter
definePageMeta({
  validate: async (route) => {
    return typeof route.params.id === 'string' && /^\d+$/.test(route.params.id)
  }
})
</script>
Optional Parameters:

Vue
<!-- pages/posts/[[slug]].vue → /posts and /posts/:slug -->
<template>
  <div>
    <div v-if="!$route.params.slug">
      <h1>All Posts</h1>
    </div>
    <div v-else>
      <h1>{{ post.title }}</h1>
    </div>
  </div>
</template>
Catch-all Routes:

Vue
<!-- pages/[...slug].vue → matches /a, /a/b, /a/b/c -->
<template>
  <div>
    <h1>Custom 404</h1>
    <p>Path: {{ $route.params.slug?.join('/') }}</p>
  </div>
</template>
5. How is layouts/ used in Nuxt 3?
Answer: Layouts define common UI structure for multiple pages:

Vue
<!-- layouts/default.vue -->
<template>
  <div class="min-h-screen flex flex-col">
    <header class="bg-blue-600 text-white p-4">
      <nav class="container mx-auto flex justify-between items-center">
        <NuxtLink to="/" class="text-xl font-bold">My App</NuxtLink>
        <div class="space-x-4">
          <NuxtLink to="/about">About</NuxtLink>
          <NuxtLink to="/contact">Contact</NuxtLink>
        </div>
      </nav>
    </header>
    
    <main class="flex-1 container mx-auto p-4">
      <slot />
    </main>
    
    <footer class="bg-gray-800 text-white p-4 text-center">
      © 2024 My App. All rights reserved.
    </footer>
  </div>
</template>
Vue
<!-- layouts/admin.vue -->
<template>
  <div class="flex">
    <aside class="w-64 bg-gray-900 text-white min-h-screen p-4">
      <h2 class="text-xl mb-4">Admin Panel</h2>
      <nav>
        <NuxtLink to="/admin/dashboard" class="block py-2">Dashboard</NuxtLink>
        <NuxtLink to="/admin/users" class="block py-2">Users</NuxtLink>
        <NuxtLink to="/admin/settings" class="block py-2">Settings</NuxtLink>
      </nav>
    </aside>
    
    <main class="flex-1 p-6">
      <slot />
    </main>
  </div>
</template>
Using layouts in pages:

Vue
<!-- pages/admin/dashboard.vue -->
<template>
  <div>
    <h1>Dashboard</h1>
    <p>Welcome to admin dashboard</p>
  </div>
</template>

<script setup>
definePageMeta({
  layout: 'admin'
})
</script>
6. What is a plugin in Nuxt 3?
Answer: Plugins are functions that extend the Vue application instance and run before the app is mounted. They're useful for adding global functionality, third-party libraries, or custom utilities.

TypeScript
// plugins/vue-toastification.client.ts
import Toast, { POSITION } from "vue-toastification"
import "vue-toastification/dist/index.css"

export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.use(Toast, {
    position: POSITION.TOP_RIGHT,
    timeout: 3000
  })
})
TypeScript
// plugins/api.ts
export default defineNuxtPlugin(() => {
  const api = {
    get: (url: string) => $fetch(url),
    post: (url: string, data: any) => $fetch(url, { method: 'POST', body: data }),
    put: (url: string, data: any) => $fetch(url, { method: 'PUT', body: data }),
    delete: (url: string) => $fetch(url, { method: 'DELETE' })
  }
  
  return {
    provide: {
      api
    }
  }
})

// Usage in component
const { $api } = useNuxtApp()
const users = await $api.get('/api/users')
Plugin Types:

.client.ts - Client-side only
.server.ts - Server-side only
.ts - Both client and server
7. What is the difference between useState() and ref()?
Answer:

Feature	useState()	ref()
Scope	Global reactive state	Component-scoped
SSR Hydration	Synced between server/client	Component instance only
Persistence	Persists across page navigation	Resets on component unmount
Usage	Shared state management	Local component state
Key Required	Yes (unique identifier)	No
TypeScript
// useState - Global state (persists across navigation)
const globalCounter = useState('counter', () => 0)
const user = useState('auth.user', () => null)

// ref - Component state (resets on navigation)
const localCount = ref(0)
const form = ref({ name: '', email: '' })

// Example usage
<script setup>
// Global state - shared across components
const shoppingCart = useState('cart', () => [])

// Local state - component specific
const isModalOpen = ref(false)
const selectedItem = ref(null)

// Global state persists when navigating away and back
const addToCart = (item) => {
  shoppingCart.value.push(item)
}
</script>
8. How do you fetch data in Nuxt 3 using useFetch()?
Answer: useFetch() is a composable for making HTTP requests with built-in SSR support:

TypeScript
<script setup>
// Basic usage
const { data: users, pending, error, refresh } = await useFetch('/api/users')

// With query parameters
const { data: posts } = await useFetch('/api/posts', {
  query: { 
    limit: 10, 
    page: 1,
    category: 'tech'
  }
})

// With headers
const { data: profile } = await useFetch('/api/profile', {
  headers: {
    'Authorization': `Bearer ${token}`
  }
})

// With transformation
const { data: transformedUsers } = await useFetch('/api/users', {
  transform: (data: any[]) => 
    data.map(user => ({
      ...user,
      fullName: `${user.firstName} ${user.lastName}`,
      avatar: user.avatar || '/default-avatar.png'
    }))
})

// POST request
const { data: newPost } = await useFetch('/api/posts', {
  method: 'POST',
  body: {
    title: 'New Post',
    content: 'Post content'
  }
})

// Reactive query
const searchQuery = ref('')
const { data: searchResults } = await useFetch('/api/search', {
  query: {
    q: searchQuery
  }
})

// Manual refresh
const refreshData = () => refresh()
</script>

<template>
  <div>
    <div v-if="pending">Loading...</div>
    <div v-else-if="error">Error: {{ error.message }}</div>
    <div v-else>
      <ul>
        <li v-for="user in users" :key="user.id">
          {{ user.fullName }}
        </li>
      </ul>
    </div>
    <button @click="refreshData">Refresh</button>
  </div>
</template>
9. What is defineNuxtPlugin() used for?
Answer: defineNuxtPlugin() creates plugins that extend the Nuxt application with custom functionality:

TypeScript
// plugins/global-components.ts
import Button from '~/components/ui/Button.vue'
import Modal from '~/components/ui/Modal.vue'

export default defineNuxtPlugin((nuxtApp) => {
  // Register global components
  nuxtApp.vueApp.component('UiButton', Button)
  nuxtApp.vueApp.component('UiModal', Modal)
})

// plugins/auth.ts
export default defineNuxtPlugin(async (nuxtApp) => {
  const user = useState('auth.user', () => null)
  
  // Check authentication on app start
  try {
    const data = await $fetch('/api/auth/me')
    user.value = data.user
  } catch (error) {
    // User not authenticated
  }
  
  const auth = {
    login: async (credentials: any) => {
      const response = await $fetch('/api/auth/login', {
        method: 'POST',
        body: credentials
      })
      user.value = response.user
      return response
    },
    
    logout: async () => {
      await $fetch('/api/auth/logout', { method: 'POST' })
      user.value = null
      await navigateTo('/login')
    }
  }
  
  return {
    provide: {
      auth
    }
  }
})

// plugins/directives.ts
export default defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.directive('focus', {
    mounted(el) {
      el.focus()
    }
  })
  
  nuxtApp.vueApp.directive('click-outside', {
    mounted(el, binding) {
      el.clickOutsideEvent = (event: Event) => {
        if (!(el === event.target || el.contains(event.target))) {
          binding.value(event)
        }
      }
      document.addEventListener('click', el.clickOutsideEvent)
    },
    unmounted(el) {
      document.removeEventListener('click', el.clickOutsideEvent)
    }
  })
})
10. How do you manage global CSS in Nuxt 3?
Answer:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  // Global CSS files
  css: [
    '~/assets/css/main.css',
    '~/assets/scss/global.scss',
    '~/assets/css/tailwind.css'
  ],
  
  // CSS preprocessing
  vite: {
    css: {
      preprocessorOptions: {
        scss: {
          additionalData: '@use "~/assets/scss/variables.scss" as *;'
        }
      }
    }
  },
  
  // PostCSS configuration
  postcss: {
    plugins: {
      tailwindcss: {},
      autoprefixer: {}
    }
  }
})
CSS
/* assets/css/main.css */
:root {
  --primary-color: #3b82f6;
  --secondary-color: #64748b;
  --background-color: #ffffff;
  --text-color: #1f2937;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', sans-serif;
  color: var(--text-color);
  background-color: var(--background-color);
  line-height: 1.6;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 1rem;
}
⚙️ Intermediate Level
11. What is the purpose of nuxt.config.ts? What are some common options?
Answer: nuxt.config.ts is the central configuration file for Nuxt applications:

TypeScript
export default defineNuxtConfig({
  // Development settings
  devtools: { enabled: true },
  devServer: {
    port: 3000,
    host: 'localhost'
  },
  
  // Rendering mode
  ssr: true, // true for SSR, false for SPA
  
  // App configuration
  app: {
    head: {
      title: 'My Nuxt App',
      htmlAttrs: {
        lang: 'en'
      },
      meta: [
        { charset: 'utf-8' },
        { name: 'viewport', content: 'width=device-width, initial-scale=1' },
        { name: 'description', content: 'My amazing Nuxt application' }
      ],
      link: [
        { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' }
      ]
    }
  },
  
  // Runtime configuration
  runtimeConfig: {
    // Private keys (server-side only)
    apiSecret: process.env.API_SECRET,
    databaseUrl: process.env.DATABASE_URL,
    
    // Public keys (exposed to client)
    public: {
      apiBase: process.env.API_BASE_URL || '/api',
      appName: 'My App'
    }
  },
  
  // Modules
  modules: [
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt',
    '@nuxtjs/google-fonts',
    '@nuxt/image'
  ],
  
  // Build configuration
  build: {
    transpile: ['@heroicons/vue']
  },
  
  // Vite configuration
  vite: {
    define: {
      __VUE_PROD_HYDRATION_MISMATCH_DETAILS__: false
    }
  },
  
  // Nitro configuration
  nitro: {
    preset: 'vercel',
    storage: {
      redis: {
        driver: 'redis',
        host: process.env.REDIS_HOST,
        port: process.env.REDIS_PORT
      }
    }
  },
  
  // Route rules for hybrid rendering
  routeRules: {
    '/': { prerender: true }, // SSG
    '/admin/**': { ssr: false }, // SPA
    '/api/**': { cors: true },
    '/blog/**': { isr: 60 } // ISR with 60s revalidation
  }
})
12. Explain how Nuxt 3 uses Nitro for server-side rendering.
Answer: Nitro is Nuxt 3's server engine that provides a unified interface for server-side rendering and deployment:

Key Features:

Universal Deployment: Works on 15+ platforms (Vercel, Netlify, Cloudflare, AWS, etc.)
Auto-optimization: Automatic code splitting, tree shaking, and minification
File-based API: Server routes in /server/api/ directory
Storage Layer: Built-in storage abstraction
Middleware Support: Server middleware for request/response handling
TypeScript
// server/api/users.get.ts
export default defineEventHandler(async (event) => {
  // Nitro automatically handles routing based on filename
  const query = getQuery(event)
  const users = await getUsersFromDatabase(query)
  
  return {
    users,
    total: users.length,
    timestamp: new Date().toISOString()
  }
})

// server/api/users/[id].get.ts
export default defineEventHandler(async (event) => {
  const id = getRouterParam(event, 'id')
  const user = await getUserById(id)
  
  if (!user) {
    throw createError({
      statusCode: 404,
      statusMessage: 'User not found'
    })
  }
  
  return user
})

// server/middleware/cors.ts
export default defineEventHandler(async (event) => {
  setHeaders(event, {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET,HEAD,PUT,PATCH,POST,DELETE',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization'
  })
  
  if (getMethod(event) === 'OPTIONS') {
    event.node.res.statusCode = 204
    event.node.res.end()
    return
  }
})
13. How do you add middleware in Nuxt 3? Give an example.
Answer: Middleware in Nuxt 3 runs before rendering pages and can be global or route-specific:

Route Middleware:

TypeScript
// middleware/auth.ts
export default defineNuxtRouteMiddleware((to, from) => {
  const user = useState('auth.user')
  
  if (!user.value) {
    return navigateTo('/login')
  }
})

// middleware/admin.ts
export default defineNuxtRouteMiddleware((to, from) => {
  const user = useState('auth.user')
  
  if (!user.value || user.value.role !== 'admin') {
    throw createError({
      statusCode: 403,
      statusMessage: 'Access denied'
    })
  }
})
Global Middleware:

TypeScript
// middleware/analytics.global.ts
export default defineNuxtRouteMiddleware((to) => {
  // Track page views
  if (process.client) {
    gtag('config', 'GA_TRACKING_ID', {
      page_path: to.fullPath
    })
  }
})

// middleware/maintenance.global.ts
export default defineNuxtRouteMiddleware(() => {
  const config = useRuntimeConfig()
  
  if (config.public.maintenanceMode && !process.dev) {
    throw createError({
      statusCode: 503,
      statusMessage: 'Site under maintenance'
    })
  }
})
Using in Pages:

Vue
<script setup>
// Single middleware
definePageMeta({
  middleware: 'auth'
})

// Multiple middleware
definePageMeta({
  middleware: ['auth', 'admin']
})

// Inline middleware
definePageMeta({
  middleware: (to, from) => {
    console.log('Navigating to:', to.path)
  }
})
</script>
14. What is the use of composables in Nuxt 3? How do you create one?
Answer: Composables are reusable functions that encapsulate reactive state and logic:

TypeScript
// composables/useAuth.ts
export const useAuth = () => {
  const user = useState('auth.user', () => null)
  const loading = ref(false)
  
  const login = async (credentials: LoginCredentials) => {
    loading.value = true
    try {
      const response = await $fetch('/api/auth/login', {
        method: 'POST',
        body: credentials
      })
      
      user.value = response.user
      await navigateTo('/dashboard')
      return response
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }
  
  const logout = async () => {
    loading.value = true
    try {
      await $fetch('/api/auth/logout', { method: 'POST' })
      user.value = null
      await navigateTo('/login')
    } finally {
      loading.value = false
    }
  }
  
  const isAuthenticated = computed(() => !!user.value)
  const isAdmin = computed(() => user.value?.role === 'admin')
  
  return {
    user: readonly(user),
    loading: readonly(loading),
    login,
    logout,
    isAuthenticated,
    isAdmin
  }
}

// composables/useApi.ts
export const useApi = () => {
  const config = useRuntimeConfig()
  
  const get = async (endpoint: string, options = {}) => {
    return await $fetch(`${config.public.apiBase}${endpoint}`, {
      method: 'GET',
      ...options
    })
  }
  
  const post = async (endpoint: string, data: any, options = {}) => {
    return await $fetch(`${config.public.apiBase}${endpoint}`, {
      method: 'POST',
      body: data,
      ...options
    })
  }
  
  return { get, post }
}

// Usage in component
<script setup>
const { user, login, logout, isAuthenticated } = useAuth()
const { get, post } = useApi()

const handleLogin = async () => {
  try {
    await login({ email: 'user@example.com', password: 'password' })
  } catch (error) {
    console.error('Login failed:', error)
  }
}
</script>
15. What is the difference between useAsyncData() and useFetch()?
Answer:

Feature	useAsyncData()	useFetch()
Purpose	Generic async data fetching	HTTP requests specifically
Fetch Function	Custom async function	Built-in $fetch
Flexibility	Any async operation	HTTP-focused with shortcuts
Key Management	Manual key required	Auto-generated key
Best For	Complex data operations	Simple API calls
TypeScript
// useAsyncData - More flexible, custom fetch function
const { data: posts, pending, error, refresh } = await useAsyncData('blog-posts', async () => {
  // Can be any async operation
  const [posts, categories] = await Promise.all([
    $fetch('/api/posts'),
    $fetch('/api/categories')
  ])
  
  return posts.map(post => ({
    ...post,
    category: categories.find(cat => cat.id === post.categoryId)
  }))
})

// useFetch - HTTP-focused, simpler syntax
const { data: users } = await useFetch('/api/users', {
  query: { limit: 10 },
  transform: (data: any[]) => data.map(user => user.name)
})

// useAsyncData with complex logic
const { data: dashboardData } = await useAsyncData('dashboard', async () => {
  const user = await getCurrentUser()
  
  if (!user) throw new Error('Not authenticated')
  
  const [stats, notifications, recentActivity] = await Promise.all([
    getUserStats(user.id),
    getNotifications(user.id),
    getRecentActivity(user.id)
  ])
  
  return {
    user,
    stats,
    notifications,
    recentActivity
  }
})

// useFetch with reactive parameters
const page = ref(1)
const { data: paginatedUsers } = await useFetch('/api/users', {
  query: { page }
})
16. How do you handle route guards in Nuxt 3?
Answer: Route guards are implemented using middleware:

TypeScript
// middleware/auth.ts
export default defineNuxtRouteMiddleware((to, from) => {
  const { isAuthenticated } = useAuth()
  
  if (!isAuthenticated.value) {
    return navigateTo('/login')
  }
})

// middleware/guest.ts
export default defineNuxtRouteMiddleware((to, from) => {
  const { isAuthenticated } = useAuth()
  
  if (isAuthenticated.value) {
    return navigateTo('/dashboard')
  }
})

// middleware/role.ts
export default defineNuxtRouteMiddleware((to, from) => {
  const { user } = useAuth()
  const requiredRole = to.meta.requiresRole
  
  if (requiredRole && user.value?.role !== requiredRole) {
    throw createError({
      statusCode: 403,
      statusMessage: 'Insufficient permissions'
    })
  }
})

// pages/admin/dashboard.vue
<script setup>
definePageMeta({
  middleware: ['auth', 'role'],
  requiresRole: 'admin'
})
</script>
17. What are server/api routes in Nuxt 3?
Answer: Server API routes provide backend functionality within your Nuxt application:

TypeScript
// server/api/users.get.ts
export default defineEventHandler(async (event) => {
  const query = getQuery(event)
  const { page = 1, limit = 10 } = query
  
  const users = await getUsersFromDatabase({
    page: Number(page),
    limit: Number(limit)
  })
  
  return {
    users,
    pagination: {
      page: Number(page),
      limit: Number(limit),
      total: users.length
    }
  }
})

// server/api/users.post.ts
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  
  // Validate input
  const validation = validateUser(body)
  if (!validation.valid) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid user data',
      data: validation.errors
    })
  }
  
  const user = await createUser(body)
  
  setResponseStatus(event, 201)
  return user
})

// server/api/users/[id].delete.ts
export default defineEventHandler(async (event) => {
  const id = getRouterParam(event, 'id')
  
  if (!id) {
    throw createError({
      statusCode: 400,
      statusMessage: 'User ID is required'
    })
  }
  
  await deleteUser(id)
  
  setResponseStatus(event, 204)
  return null
})

// server/api/auth/login.post.ts
export default defineEventHandler(async (event) => {
  const { email, password } = await readBody(event)
  
  const user = await authenticateUser(email, password)
  
  if (!user) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Invalid credentials'
    })
  }
  
  const token = generateJWT(user)
  
  setCookie(event, 'auth-token', token, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 // 7 days
  })
  
  return { user, token }
})
18. How do you make an authenticated API call in Nuxt 3?
Answer:

TypeScript
// composables/useAuthenticatedFetch.ts
export const useAuthenticatedFetch = () => {
  const { token } = useAuth()
  
  const authenticatedFetch = (url: string, options: any = {}) => {
    return useFetch(url, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${token.value}`
      }
    })
  }
  
  return { authenticatedFetch }
}

// Usage in component
<script setup>
const { authenticatedFetch } = useAuthenticatedFetch()

const { data: profile } = await authenticatedFetch('/api/profile')
const { data: orders } = await authenticatedFetch('/api/orders', {
  query: { status: 'pending' }
})
</script>

// Alternative approach with plugin
// plugins/auth-fetch.ts
export default defineNuxtPlugin(() => {
  const { token } = useAuth()
  
  $fetch.create({
    onRequest({ request, options }) {
      if (token.value) {
        options.headers = {
          ...options.headers,
          Authorization: `Bearer ${token.value}`
        }
      }
    },
    
    onResponseError({ response }) {
      if (response.status === 401) {
        // Handle token expiration
        navigateTo('/login')
      }
    }
  })
})
19. What is app.vue used for in Nuxt 3?
Answer: app.vue is the main component that wraps around all pages and serves as the root of your application:

Vue
<!-- app.vue -->
<template>
  <div>
    <!-- Global components that appear on every page -->
    <NuxtLoadingIndicator />
    
    <!-- Navigation -->
    <AppHeader v-if="!isFullScreen" />
    
    <!-- Main content area where pages are rendered -->
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
    
    <!-- Global modals -->
    <GlobalModal />
    
    <!-- Toast notifications -->
    <ToastContainer />
    
    <!-- Footer -->
    <AppFooter v-if="!isFullScreen" />
  </div>
</template>

<script setup>
// Global logic that runs on every page
const route = useRoute()

// Hide header/footer on certain pages
const isFullScreen = computed(() => {
  return route.path.startsWith('/login') || 
         route.path.startsWith('/signup') ||
         route.path.startsWith('/admin')
})

// Global error handling
onErrorCaptured((error) => {
  console.error('Global error:', error)
  // Send to error tracking service
})

// Global metadata
useHead({
  titleTemplate: (title) => title ? `${title} - My App` : 'My App',
  meta: [
    { name: 'viewport', content: 'width=device-width, initial-scale=1' }
  ]
})
</script>
20. How do you use modules in Nuxt 3?
Answer: Modules extend Nuxt functionality:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: [
    // Official modules
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt',
    '@nuxt/image',
    '@nuxtjs/google-fonts',
    
    // Community modules
    '@nuxtjs/supabase',
    '@vueuse/nuxt',
    
    // Local modules
    '~/modules/custom-module'
  ],
  
  // Module configuration
  tailwindcss: {
    configPath: 'tailwind.config.js'
  },
  
  googleFonts: {
    families: {
      Inter: [400, 500, 600, 700]
    }
  },
  
  image: {
    cloudinary: {
      baseURL: 'https://res.cloudinary.com/demo/image/upload/'
    }
  }
})

// modules/custom-module.ts
import { defineNuxtModule, addPlugin, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'custom-module',
    configKey: 'customModule'
  },
  
  defaults: {
    apiKey: ''
  },
  
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)
    
    // Add plugin
    addPlugin(resolver.resolve('./runtime/plugin'))
    
    // Add composables
    nuxt.hook('imports:dirs', (dirs) => {
      dirs.push(resolver.resolve('./runtime/composables'))
    })
  }
})
🧠 Advanced Level
21. How does Nuxt 3 handle SSR (Server-Side Rendering) and SSG (Static Site Generation)?
Answer: Nuxt 3 provides flexible rendering modes through configuration:

SSR Configuration:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  ssr: true, // Default - enables SSR
  
  // Hybrid rendering - mix SSR/SSG per route
  routeRules: {
    '/': { prerender: true }, // SSG for homepage
    '/about': { prerender: true }, // SSG for about page
    '/blog/**': { isr: 60 }, // ISR with 60s revalidation
    '/admin/**': { ssr: false }, // SPA for admin
    '/api/**': { cors: true }
  }
})
SSG Implementation:

bash
# Generate static site
npm run generate

# Or prerender specific routes
npm run build --prerender
Runtime Rendering Control:

Vue
<template>
  <div>
    <div v-if="$route.path.startsWith('/admin')">
      <!-- SPA content -->
      <ClientOnly>
        <AdminDashboard />
      </ClientOnly>
    </div>
    <div v-else>
      <!-- SSR content -->
      <ServerRenderedContent />
    </div>
  </div>
</template>

<script setup>
// Control rendering per component
const isClient = process.client
const isServer = process.server

// Data fetching strategies
const { data: staticData } = await useFetch('/api/static-content', {
  server: true, // Only fetch on server
  client: false
})

const { data: dynamicData } = await useFetch('/api/dynamic-content', {
  server: false, // Only fetch on client
  client: true
})
</script>
22. How would you optimize performance in a Nuxt 3 app?
Answer: Bundle Optimization:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  // Code splitting
  experimental: {
    payloadExtraction: false // Reduce payload size
  },
  
  // Optimize builds
  build: {
    splitChunks: {
      layouts: true,
      pages: true,
      commons: true
    }
  },
  
  // Tree shaking
  nitro: {
    minify: true,
    experimental: {
      wasm: true
    }
  }
})
Lazy Loading:

Vue
<template>
  <div>
    <!-- Lazy load components -->
    <LazyAdminPanel v-if="showAdmin" />
    
    <!-- Lazy load images -->
    <NuxtImg
      src="/hero.jpg"
      loading="lazy"
      placeholder="/placeholder.jpg"
    />
    
    <!-- Lazy load heavy content -->
    <ClientOnly>
      <HeavyChart />
      <template #fallback>
        <div>Loading chart...</div>
      </template>
    </ClientOnly>
  </div>
</template>

<script setup>
// Lazy load data
const { data: heavyData } = await useLazyFetch('/api/heavy-data')

// Prefetch on hover
const prefetchData = () => {
  $fetch('/api/prefetch-data')
}
</script>
Caching Strategies:

TypeScript
// server/api/cached-data.get.ts
export default defineCachedEventHandler(async (event) => {
  const data = await expensiveOperation()
  return data
}, {
  maxAge: 60 * 10, // 10 minutes
  group: 'api',
  varies: ['Authorization']
})
23. How does the Nitro engine work? What are its deployment targets?
Answer: Nitro is Nuxt 3's server engine providing universal deployment:

Architecture:

Build-time optimization: Code splitting, tree shaking, minification
Runtime adapters: Different deployment targets
Storage layer: Unified storage abstraction
Route handling: File-based API routes
Deployment Targets:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    preset: 'vercel', // Choose deployment target
    
    // Available presets:
    // 'node-server' - Node.js server
    // 'vercel' - Vercel
    // 'netlify' - Netlify
    // 'cloudflare-pages' - Cloudflare Pages
    // 'aws-lambda' - AWS Lambda
    // 'azure' - Azure Functions
    // 'firebase' - Firebase Functions
    // 'heroku' - Heroku
    // 'digital-ocean' - DigitalOcean
    
    storage: {
      redis: {
        driver: 'redis',
        host: process.env.REDIS_HOST
      }
    }
  }
})
24. How would you implement authentication and authorization in Nuxt 3?
Answer: Complete Auth System:

TypeScript
// composables/useAuth.ts
export const useAuth = () => {
  const user = useState<User | null>('auth.user', () => null)
  const token = useCookie('auth-token', {
    default: () => null,
    httpOnly: true,
    secure: true,
    sameSite: 'strict'
  })
  
  const login = async (credentials: LoginCredentials) => {
    const { data } = await $fetch('/api/auth/login', {
      method: 'POST',
      body: credentials
    })
    
    user.value = data.user
    token.value = data.token
    
    await navigateTo('/dashboard')
  }
  
  const logout = async () => {
    await $fetch('/api/auth/logout', {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token.value}`
      }
    })
    
    user.value = null
    token.value = null
    await navigateTo('/login')
  }
  
  const hasRole = (role: string) => {
    return user.value?.roles?.includes(role) ?? false
  }
  
  const hasPermission = (permission: string) => {
    return user.value?.permissions?.includes(permission) ?? false
  }
  
  return {
    user: readonly(user),
    login,
    logout,
    hasRole,
    hasPermission,
    isAuthenticated: computed(() => !!user.value)
  }
}

// middleware/auth.ts
export default defineNuxtRouteMiddleware(() => {
  const { isAuthenticated } = useAuth()
  
  if (!isAuthenticated.value) {
    return navigateTo('/login')
  }
})

// middleware/role.ts
export default defineNuxtRouteMiddleware((to) => {
  const { hasRole } = useAuth()
  const requiredRole = to.meta.requiresRole
  
  if (requiredRole && !hasRole(requiredRole)) {
    throw createError({
      statusCode: 403,
      statusMessage: 'Access denied'
    })
  }
})

// server/api/auth/login.post.ts
import jwt from 'jsonwebtoken'
import bcrypt from 'bcrypt'

export default defineEventHandler(async (event) => {
  const { email, password } = await readBody(event)
  
  const user = await findUserByEmail(email)
  
  if (!user || !await bcrypt.compare(password, user.hashedPassword)) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Invalid credentials'
    })
  }
  
  const token = jwt.sign(
    { userId: user.id, email: user.email },
    process.env.JWT_SECRET,
    { expiresIn: '7d' }
  )
  
  setCookie(event, 'auth-token', token, {
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60
  })
  
  return {
    user: {
      id: user.id,
      email: user.email,
      name: user.name,
      roles: user.roles
    },
    token
  }
})
25. What is the difference between defineNuxtPlugin, defineNuxtRouteMiddleware, and defineNuxtComponent?
Answer:

Function	Purpose	Usage	Execution
defineNuxtPlugin	Extend Vue app	Add global functionality	App initialization
defineNuxtRouteMiddleware	Route protection	Navigation guards	Before route change
defineNuxtComponent	Component definition	Create components	Component render
TypeScript
// defineNuxtPlugin - App-level functionality
export default defineNuxtPlugin((nuxtApp) => {
  // Runs once when app initializes
  const analytics = {
    track: (event: string, data: any) => {
      // Analytics implementation
    }
  }
  
  return {
    provide: {
      analytics
    }
  }
})

// defineNuxtRouteMiddleware - Route-level logic
export default defineNuxtRouteMiddleware((to, from) => {
  // Runs before every route change
  console.log(`Navigating from ${from.path} to ${to.path}`)
  
  if (to.path === '/restricted') {
    return navigateTo('/login')
  }
})

// defineNuxtComponent - Component definition
export default defineNuxtComponent({
  name: 'CustomButton',
  props: {
    variant: {
      type: String,
      default: 'primary'
    }
  },
  setup(props) {
    const classes = computed(() => {
      return `btn btn-${props.variant}`
    })
    
    return { classes }
  }
})
26. How do you use runtime config in Nuxt 3?
Answer:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  runtimeConfig: {
    // Private keys (server-side only)
    apiSecret: process.env.API_SECRET,
    databaseUrl: process.env.DATABASE_URL,
    jwtSecret: process.env.JWT_SECRET,
    
    // Public keys (exposed to client-side)
    public: {
      apiBase: process.env.API_BASE_URL || 'http://localhost:3000/api',
      appName: 'My App',
      version: process.env.npm_package_version,
      environment: process.env.NODE_ENV
    }
  }
})

// Usage in server API
// server/api/protected.get.ts
export default defineEventHandler(async (event) => {
  const config = useRuntimeConfig()
  
  // Access private config (server-side only)
  const secret = config.apiSecret
  
  // Validate request using secret
  const isValid = validateRequest(event, secret)
  
  if (!isValid) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Unauthorized'
    })
  }
  
  return { message: 'Access granted' }
})

// Usage in components
<script setup>
const config = useRuntimeConfig()

// Access public config (available on both server and client)
const apiBase = config.public.apiBase
const appName = config.public.appName

// Make API calls using config
const { data } = await $fetch(`${apiBase}/users`)
</script>

// Usage in composables
export const useApi = () => {
  const config = useRuntimeConfig()
  
  const apiCall = async (endpoint: string) => {
    return await $fetch(`${config.public.apiBase}${endpoint}`)
  }
  
  return { apiCall }
}
27. Explain the auto-import mechanism of Nuxt 3.
Answer: Nuxt 3 automatically imports components, composables, and utilities:

Directory-based Auto-imports:

components/ - Vue components
composables/ - Composable functions
utils/ - Utility functions
plugins/ - Plugins
TypeScript
// components/ui/Button.vue
export default defineComponent({
  name: 'UiButton'
})

// Usage without explicit import
<template>
  <UiButton>Click me</UiButton>
</template>

// composables/useCounter.ts
export const useCounter = () => {
  const count = ref(0)
  return { count }
}

// Usage without explicit import
<script setup>
const { count } = useCounter() // Auto-imported
</script>

// utils/formatDate.ts
export const formatDate = (date: Date) => {
  return date.toLocaleDateString()
}

// Usage without explicit import
<script setup>
const formattedDate = formatDate(new Date()) // Auto-imported
</script>
Configuration:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  imports: {
    // Disable auto-imports
    autoImport: false,
    
    // Add custom directories
    dirs: [
      'stores',
      'types/*.ts'
    ],
    
    // Add third-party imports
    presets: [
      {
        from: 'lodash',
        imports: ['debounce', 'throttle']
      }
    ]
  }
})
28. How can you customize the head tags (title, meta) dynamically in Nuxt 3?
Answer:

Vue
<script setup>
// Dynamic head management
const route = useRoute()

// Basic head tags
useHead({
  title: 'My Page Title',
  meta: [
    { name: 'description', content: 'Page description' },
    { property: 'og:title', content: 'My Page Title' },
    { property: 'og:description', content: 'Page description' }
  ]
})

// Reactive head tags
const pageTitle = ref('Dynamic Title')
const pageDescription = ref('Dynamic description')

useHead({
  title: pageTitle,
  meta: [
    { name: 'description', content: pageDescription }
  ]
})

// SEO optimization
useSeoMeta({
  title: 'My Page',
  ogTitle: 'My Page',
  description: 'My page description',
  ogDescription: 'My page description',
  ogImage: '/og-image.jpg',
  twitterCard: 'summary_large_image'
})

// Dynamic based on data
const { data: post } = await useFetch(`/api/posts/${route.params.slug}`)

useHead({
  title: () => post.value?.title,
  meta: [
    { name: 'description', content: () => post.value?.excerpt },
    { property: 'og:title', content: () => post.value?.title },
    { property: 'og:image', content: () => post.value?.featuredImage }
  ]
})

// Structured data
useJsonld({
  '@context': 'https://schema.org',
  '@type': 'Article',
  headline: () => post.value?.title,
  author: {
    '@type': 'Person',
    name: () => post.value?.author
  }
})
</script>

<template>
  <div>
    <h1>{{ post?.title }}</h1>
    <p>{{ post?.content }}</p>
  </div>
</template>
29. How do you handle error pages in Nuxt 3?
Answer:

Vue
<!-- error.vue in root directory -->
<template>
  <div class="error-page min-h-screen flex items-center justify-center">
    <div class="text-center">
      <h1 class="text-6xl font-bold text-gray-900 mb-4">
        {{ error.statusCode }}
      </h1>
      
      <h2 class="text-2xl font-semibold text-gray-700 mb-6">
        {{ getErrorMessage(error.statusCode) }}
      </h2>
      
      <p class="text-gray-600 mb-8">
        {{ error.statusMessage }}
      </p>
      
      <div class="space-x-4">
        <button
          @click="handleError"
          class="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700"
        >
          {{ getActionText(error.statusCode) }}
        </button>
        
        <NuxtLink
          to="/"
          class="bg-gray-600 text-white px-6 py-3 rounded-lg hover:bg-gray-700"
        >
          Go Home
        </NuxtLink>
      </div>
    </div>
  </div>
</template>

<script setup>
interface NuxtError {
  statusCode: number
  statusMessage: string
  message?: string
}

const props = defineProps<{
  error: NuxtError
}>()

const getErrorMessage = (code: number) => {
  const messages = {
    404: 'Page Not Found',
    500: 'Internal Server Error',
    403: 'Access Forbidden',
    401: 'Unauthorized Access'
  }
  return messages[code] || 'Something went wrong'
}

const getActionText = (code: number) => {
  return code === 404 ? 'Go Back' : 'Try Again'
}

const handleError = () => {
  if (props.error.statusCode === 404) {
    navigateTo('/')
  } else {
    clearError({ redirect: '/' })
  }
}

// Custom error reporting
onMounted(() => {
  // Send error to monitoring service
  if (process.client) {
    reportError({
      statusCode: props.error.statusCode,
      message: props.error.statusMessage,
      url: window.location.href,
      userAgent: navigator.userAgent
    })
  }
})
</script>

// Custom error throwing
<script setup>
// In pages or components
const { data: user } = await useFetch('/api/user')

if (!user.value) {
  throw createError({
    statusCode: 404,
    statusMessage: 'User not found'
  })
}

// Conditional error
if (process.server && someCondition) {
  throw createError({
    statusCode: 500,
    statusMessage: 'Server processing error'
  })
}
</script>
30. How do you test a Nuxt 3 application (unit, integration, and E2E)?
Answer: Unit Testing Setup:

TypeScript
// vitest.config.ts
import { defineVitestConfig } from '@nuxt/test-utils/config'

export default defineVitestConfig({
  test: {
    environment: 'nuxt'
  }
})

// tests/components/Button.test.ts
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import Button from '~/components/ui/Button.vue'

describe('Button Component', () => {
  it('renders with correct text', () => {
    const wrapper = mount(Button, {
      props: { label: 'Click me' }
    })
    
    expect(wrapper.text()).toContain('Click me')
  })
  
  it('emits click event', async () => {
    const wrapper = mount(Button)
    
    await wrapper.trigger('click')
    
    expect(wrapper.emitted('click')).toBeTruthy()
  })
})

// tests/composables/useAuth.test.ts
import { describe, it, expect, vi } from 'vitest'
import { useAuth } from '~/composables/useAuth'

vi.mock('#app', () => ({
  useState: vi.fn(() => ref(null)),
  navigateTo: vi.fn(),
  $fetch: vi.fn()
}))

describe('useAuth', () => {
  it('should login user', async () => {
    const { login } = useAuth()
    
    vi.mocked($fetch).mockResolvedValue({
      user: { id: 1, name: 'John' },
      token: 'abc123'
    })
    
    await login({ email: 'test@test.com', password: 'password' })
    
    expect($fetch).toHaveBeenCalledWith('/api/auth/login', {
      method: 'POST',
      body: { email: 'test@test.com', password: 'password' }
    })
  })
})
Integration Testing:

TypeScript
// tests/api/users.test.ts
import { describe, it, expect } from 'vitest'
import { $fetch, setup } from '@nuxt/test-utils'

describe('/api/users', () => {
  await setup({
    server: true
  })
  
  it('should return users list', async () => {
    const users = await $fetch('/api/users')
    
    expect(users).toHaveProperty('data')
    expect(Array.isArray(users.data)).toBe(true)
  })
  
  it('should create new user', async () => {
    const newUser = await $fetch('/api/users', {
      method: 'POST',
      body: {
        name: 'John Doe',
        email: 'john@example.com'
      }
    })
    
    expect(newUser).toHaveProperty('id')
    expect(newUser.name).toBe('John Doe')
  })
})
E2E Testing:

TypeScript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  use: {
    baseURL: 'http://localhost:3000'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    }
  ]
})

// tests/e2e/auth.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Authentication Flow', () => {
  test('should login user', async ({ page }) => {
    await page.goto('/login')
    
    await page.fill('input[name="email"]', 'test@example.com')
    await page.fill('input[name="password"]', 'password')
    await page.click('button[type="submit"]')
    
    await expect(page).toHaveURL('/dashboard')
    await expect(page.locator('h1')).toContainText('Dashboard')
  })
  
  test('should redirect to login when not authenticated', async ({ page }) => {
    await page.goto('/dashboard')
    
    await expect(page).toHaveURL('/login')
  })
})
🚀 Deployment & DevOps
31. How do you deploy a Nuxt 3 app on Vercel/Netlify/Heroku?
Answer: Vercel Deployment:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    preset: 'vercel-edge' // or 'vercel'
  }
})
JSON
// vercel.json
{
  "builds": [
    {
      "src": "nuxt.config.ts",
      "use": "@nuxtjs/vercel-builder"
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "/api/$1"
    }
  ]
}
Netlify Deployment:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    preset: 'netlify'
  }
})
TOML
# netlify.toml
[build]
  command = "npm run build"
  publish = "dist"

[build.environment]
  NODE_VERSION = "18"

[[redirects]]
  from = "/*"
  to = "/index.html"
  status = 200
Heroku Deployment:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    preset: 'node-server'
  }
})
JSON
// package.json
{
  "scripts": {
    "start": "node .output/server/index.mjs",
    "heroku-postbuild": "npm run build"
  },
  "engines": {
    "node": "18.x"
  }
}
32. What are the steps to enable SSR on shared hosting like cPanel?
Answer:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    preset: 'node-server',
    output: {
      dir: '.output'
    }
  }
})
Steps:

Build the application: npm run build
Upload .output folder to hosting
Set Node.js version in cPanel
Create startup file:
JavaScript
// app.js
const { loadNuxt, build } = require('nuxt')

const isDev = process.env.NODE_ENV !== 'production'
const nuxt = await loadNuxt(isDev ? 'dev' : 'start')

if (isDev) {
  build(nuxt)
}

const { port = 3000 } = process.env
nuxt.listen(port, '0.0.0.0')
33. How do you configure environment variables in Nuxt 3?
Answer:

bash
# .env
# Private variables (server-only)
DATABASE_URL=postgresql://localhost:5432/mydb
API_SECRET=your-secret-key
JWT_SECRET=jwt-secret

# Public variables (exposed to client)
NUXT_PUBLIC_API_BASE=https://api.example.com
NUXT_PUBLIC_APP_NAME=My App
NUXT_PUBLIC_ENVIRONMENT=development
TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  runtimeConfig: {
    // Private keys
    databaseUrl: process.env.DATABASE_URL,
    apiSecret: process.env.API_SECRET,
    jwtSecret: process.env.JWT_SECRET,
    
    // Public keys
    public: {
      apiBase: process.env.NUXT_PUBLIC_API_BASE,
      appName: process.env.NUXT_PUBLIC_APP_NAME,
      environment: process.env.NUXT_PUBLIC_ENVIRONMENT
    }
  }
})

// Different environments
// .env.development
NUXT_PUBLIC_API_BASE=http://localhost:3001/api

// .env.production
NUXT_PUBLIC_API_BASE=https://api.myapp.com

// .env.staging
NUXT_PUBLIC_API_BASE=https://staging-api.myapp.com
34. What are edge functions and how are they supported in Nuxt 3?
Answer: Edge functions run closer to users for better performance:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  nitro: {
    preset: 'vercel-edge', // or 'netlify-edge', 'cloudflare-pages'
    
    // Edge-specific configuration
    rollupConfig: {
      external: ['node:fs', 'node:path'] // Exclude Node.js APIs
    }
  }
})

// server/api/edge-function.ts
export default defineEventHandler(async (event) => {
  // Edge-compatible code (no Node.js APIs)
  const userAgent = getHeader(event, 'user-agent')
  const geo = event.context.cloudflare?.cf || {}
  
  return {
    message: 'Hello from edge',
    location: geo.country
You said: continue
continue
Copilot said: ```typescript userAgent,
TypeScript
    userAgent,
    timestamp: new Date().toISOString()
  }
})

// Edge-compatible data fetching
export default defineEventHandler(async (event) => {
  // Use fetch instead of Node.js modules
  const response = await fetch('https://api.example.com/data')
  const data = await response.json()
  
  return {
    data,
    edge: true,
    region: process.env.VERCEL_REGION
  }
})
35. How would you deploy a Nuxt 3 app with Docker?
Answer:

Dockerfile
# Dockerfile
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Copy package files
COPY package.json package-lock.json* ./
RUN npm ci --only=production && npm cache clean --force

# Build the app
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Build application
RUN npm run build

# Production image
FROM base AS runner
WORKDIR /app

# Create non-root user
RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nuxtjs

# Copy built application
COPY --from=builder --chown=nuxtjs:nodejs /app/.output ./.output

USER nuxtjs

EXPOSE 3000

ENV PORT 3000
ENV NODE_ENV production

CMD ["node", ".output/server/index.mjs"]
YAML
# docker-compose.yml
version: '3.8'

services:
  nuxt-app:
    build: .
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - API_SECRET=${API_SECRET}
    depends_on:
      - redis
      - postgres

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: nuxtapp
      POSTGRES_USER: nuxtuser
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
bash
# .dockerignore
node_modules
npm-debug.log
.nuxt
.output
.git
.gitignore
README.md
.env
.nyc_output
coverage
.cache
🔌 Ecosystem & Tooling
36. How do you integrate Tailwind CSS with Nuxt 3?
Answer:

bash
npm install @nuxtjs/tailwindcss
TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: ['@nuxtjs/tailwindcss'],
  
  tailwindcss: {
    cssPath: '~/assets/css/tailwind.css',
    configPath: 'tailwind.config.js',
    exposeConfig: false,
    viewer: true, // Enable Tailwind viewer in dev
    
    config: {
      darkMode: 'class',
      theme: {
        extend: {
          colors: {
            primary: {
              50: '#eff6ff',
              500: '#3b82f6',
              900: '#1e3a8a'
            }
          }
        }
      }
    }
  }
})
CSS
/* assets/css/tailwind.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer components {
  .btn {
    @apply px-4 py-2 rounded-lg font-medium transition-colors;
  }
  
  .btn-primary {
    @apply bg-primary-500 text-white hover:bg-primary-600;
  }
  
  .btn-secondary {
    @apply bg-gray-200 text-gray-900 hover:bg-gray-300;
  }
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}
JavaScript
// tailwind.config.js
module.exports = {
  content: [
    './components/**/*.{js,vue,ts}',
    './layouts/**/*.vue',
    './pages/**/*.vue',
    './plugins/**/*.{js,ts}',
    './nuxt.config.{js,ts}',
    './app.vue'
  ],
  
  theme: {
    extend: {
      fontFamily: {
        sans: ['Inter', 'sans-serif']
      },
      
      animation: {
        'fade-in': 'fadeIn 0.5s ease-in-out',
        'slide-up': 'slideUp 0.3s ease-out'
      },
      
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' }
        },
        slideUp: {
          '0%': { transform: 'translateY(10px)', opacity: '0' },
          '100%': { transform: 'translateY(0)', opacity: '1' }
        }
      }
    }
  },
  
  plugins: [
    require('@tailwindcss/forms'),
    require('@tailwindcss/typography'),
    require('@tailwindcss/aspect-ratio')
  ]
}
37. How do you integrate and configure Axios in Nuxt 3?
Answer: While Nuxt 3 uses $fetch by default, you can still integrate Axios:

bash
npm install axios
TypeScript
// plugins/axios.ts
import axios from 'axios'

export default defineNuxtPlugin(() => {
  const config = useRuntimeConfig()
  
  const api = axios.create({
    baseURL: config.public.apiBase,
    timeout: 10000
  })
  
  // Request interceptor
  api.interceptors.request.use(
    (config) => {
      const token = useCookie('auth-token')
      
      if (token.value) {
        config.headers.Authorization = `Bearer ${token.value}`
      }
      
      return config
    },
    (error) => Promise.reject(error)
  )
  
  // Response interceptor
  api.interceptors.response.use(
    (response) => response,
    (error) => {
      if (error.response?.status === 401) {
        // Handle token expiration
        navigateTo('/login')
      }
      
      return Promise.reject(error)
    }
  )
  
  return {
    provide: {
      axios: api
    }
  }
})

// composables/useAxios.ts
export const useAxios = () => {
  const { $axios } = useNuxtApp()
  
  const get = async (url: string, config = {}) => {
    try {
      const response = await $axios.get(url, config)
      return { data: response.data, error: null }
    } catch (error) {
      return { data: null, error }
    }
  }
  
  const post = async (url: string, data: any, config = {}) => {
    try {
      const response = await $axios.post(url, data, config)
      return { data: response.data, error: null }
    } catch (error) {
      return { data: null, error }
    }
  }
  
  return { get, post, axios: $axios }
}

// Usage in component
<script setup>
const { get, post } = useAxios()

const { data: users, error } = await get('/users')

const createUser = async (userData) => {
  const { data, error } = await post('/users', userData)
  
  if (error) {
    console.error('Failed to create user:', error)
  } else {
    console.log('User created:', data)
  }
}
</script>
Alternative with $fetch wrapper:

TypeScript
// composables/useApi.ts
export const useApi = () => {
  const config = useRuntimeConfig()
  
  const api = $fetch.create({
    baseURL: config.public.apiBase,
    
    onRequest({ request, options }) {
      const token = useCookie('auth-token')
      
      if (token.value) {
        options.headers = {
          ...options.headers,
          Authorization: `Bearer ${token.value}`
        }
      }
    },
    
    onResponseError({ response }) {
      if (response.status === 401) {
        navigateTo('/login')
      }
    }
  })
  
  return api
}
38. What is the role of Pinia and how do you use it in Nuxt 3?
Answer: Pinia is the recommended state management library for Vue 3 and Nuxt 3:

bash
npm install @pinia/nuxt pinia
TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: ['@pinia/nuxt'],
  
  pinia: {
    autoImports: [
      'defineStore',
      'storeToRefs'
    ]
  }
})

// stores/auth.ts
export const useAuthStore = defineStore('auth', () => {
  // State
  const user = ref<User | null>(null)
  const token = ref<string | null>(null)
  const loading = ref(false)
  
  // Getters
  const isAuthenticated = computed(() => !!user.value)
  const isAdmin = computed(() => user.value?.role === 'admin')
  const fullName = computed(() => 
    user.value ? `${user.value.firstName} ${user.value.lastName}` : ''
  )
  
  // Actions
  const login = async (credentials: LoginCredentials) => {
    loading.value = true
    
    try {
      const response = await $fetch('/api/auth/login', {
        method: 'POST',
        body: credentials
      })
      
      user.value = response.user
      token.value = response.token
      
      // Persist token
      const tokenCookie = useCookie('auth-token')
      tokenCookie.value = response.token
      
      return response
    } catch (error) {
      throw error
    } finally {
      loading.value = false
    }
  }
  
  const logout = async () => {
    loading.value = true
    
    try {
      await $fetch('/api/auth/logout', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token.value}`
        }
      })
    } finally {
      user.value = null
      token.value = null
      
      const tokenCookie = useCookie('auth-token')
      tokenCookie.value = null
      
      loading.value = false
      
      await navigateTo('/login')
    }
  }
  
  const fetchProfile = async () => {
    if (!token.value) return
    
    try {
      const profile = await $fetch('/api/auth/profile', {
        headers: {
          Authorization: `Bearer ${token.value}`
        }
      })
      
      user.value = profile
    } catch (error) {
      // Token might be invalid
      logout()
    }
  }
  
  return {
    // State
    user,
    token,
    loading,
    
    // Getters
    isAuthenticated,
    isAdmin,
    fullName,
    
    // Actions
    login,
    logout,
    fetchProfile
  }
})

// stores/cart.ts
export const useCartStore = defineStore('cart', () => {
  const items = ref<CartItem[]>([])
  
  const totalItems = computed(() => 
    items.value.reduce((total, item) => total + item.quantity, 0)
  )
  
  const totalPrice = computed(() =>
    items.value.reduce((total, item) => total + (item.price * item.quantity), 0)
  )
  
  const addItem = (product: Product, quantity = 1) => {
    const existingItem = items.value.find(item => item.id === product.id)
    
    if (existingItem) {
      existingItem.quantity += quantity
    } else {
      items.value.push({
        id: product.id,
        name: product.name,
        price: product.price,
        quantity
      })
    }
  }
  
  const removeItem = (itemId: string) => {
    const index = items.value.findIndex(item => item.id === itemId)
    if (index > -1) {
      items.value.splice(index, 1)
    }
  }
  
  const clearCart = () => {
    items.value = []
  }
  
  return {
    items,
    totalItems,
    totalPrice,
    addItem,
    removeItem,
    clearCart
  }
}, {
  persist: true // Persist cart data
})

// Usage in components
<script setup>
const authStore = useAuthStore()
const cartStore = useCartStore()

// Using storeToRefs for reactivity
const { user, loading, isAuthenticated } = storeToRefs(authStore)
const { items, totalItems, totalPrice } = storeToRefs(cartStore)

// Using actions directly
const handleLogin = async () => {
  try {
    await authStore.login({
      email: 'user@example.com',
      password: 'password'
    })
  } catch (error) {
    console.error('Login failed:', error)
  }
}

const addToCart = (product) => {
  cartStore.addItem(product)
}
</script>

<template>
  <div>
    <div v-if="loading">Loading...</div>
    
    <div v-else-if="isAuthenticated">
      <h1>Welcome, {{ user.firstName }}!</h1>
      <p>Cart items: {{ totalItems }}</p>
      <p>Total: ${{ totalPrice }}</p>
    </div>
    
    <div v-else>
      <button @click="handleLogin">Login</button>
    </div>
  </div>
</template>
39. How would you implement internationalization (i18n) in Nuxt 3?
Answer:

bash
npm install @nuxtjs/i18n
TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: ['@nuxtjs/i18n'],
  
  i18n: {
    locales: [
      { code: 'en', name: 'English', file: 'en.json' },
      { code: 'es', name: 'Español', file: 'es.json' },
      { code: 'fr', name: 'Français', file: 'fr.json' },
      { code: 'de', name: 'Deutsch', file: 'de.json' }
    ],
    
    defaultLocale: 'en',
    
    strategy: 'prefix_except_default', // URLs: /es/about, /about
    
    detectBrowserLanguage: {
      useCookie: true,
      cookieKey: 'i18n_redirected',
      redirectOn: 'root'
    },
    
    lazy: true,
    langDir: 'locales/',
    
    vueI18n: './i18n.config.ts'
  }
})

// i18n.config.ts
export default defineI18nConfig(() => ({
  legacy: false,
  locale: 'en',
  fallbackLocale: 'en',
  
  numberFormats: {
    en: {
      currency: {
        style: 'currency',
        currency: 'USD'
      }
    },
    es: {
      currency: {
        style: 'currency',
        currency: 'EUR'
      }
    }
  },
  
  datetimeFormats: {
    en: {
      short: {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      },
      long: {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        weekday: 'long'
      }
    }
  }
}))
JSON
// locales/en.json
{
  "welcome": "Welcome",
  "hello": "Hello {name}",
  "nav": {
    "home": "Home",
    "about": "About",
    "contact": "Contact"
  },
  "user": {
    "profile": "Profile",
    "settings": "Settings",
    "logout": "Logout"
  },
  "validation": {
    "required": "This field is required",
    "email": "Please enter a valid email",
    "password": "Password must be at least 8 characters"
  },
  "product": {
    "price": "Price: {price}",
    "inStock": "In Stock: {count}",
    "outOfStock": "Out of Stock"
  }
}

// locales/es.json
{
  "welcome": "Bienvenido",
  "hello": "Hola {name}",
  "nav": {
    "home": "Inicio",
    "about": "Acerca de",
    "contact": "Contacto"
  },
  "user": {
    "profile": "Perfil",
    "settings": "Configuración",
    "logout": "Cerrar sesión"
  },
  "validation": {
    "required": "Este campo es obligatorio",
    "email": "Por favor ingrese un email válido",
    "password": "La contraseña debe tener al menos 8 caracteres"
  }
}
Vue
<!-- components/LocaleSwitcher.vue -->
<template>
  <div class="locale-switcher">
    <select @change="changeLocale" :value="locale">
      <option 
        v-for="loc in availableLocales" 
        :key="loc.code" 
        :value="loc.code"
      >
        {{ loc.name }}
      </option>
    </select>
  </div>
</template>

<script setup>
const { locale, locales, setLocale } = useI18n()

const availableLocales = computed(() => {
  return locales.value.filter(loc => loc.code !== locale.value)
})

const changeLocale = async (event) => {
  await setLocale(event.target.value)
}
</script>

<!-- Usage in pages/components -->
<template>
  <div>
    <LocaleSwitcher />
    
    <nav>
      <NuxtLink :to="localePath('/')">{{ $t('nav.home') }}</NuxtLink>
      <NuxtLink :to="localePath('/about')">{{ $t('nav.about') }}</NuxtLink>
      <NuxtLink :to="localePath('/contact')">{{ $t('nav.contact') }}</NuxtLink>
    </nav>
    
    <h1>{{ $t('welcome') }}</h1>
    <p>{{ $t('hello', { name: 'John' }) }}</p>
    
    <!-- Number formatting -->
    <p>{{ $n(1234.56, 'currency') }}</p>
    
    <!-- Date formatting -->
    <p>{{ $d(new Date(), 'short') }}</p>
    
    <!-- Pluralization -->
    <p>{{ $tc('product.inStock', stockCount, { count: stockCount }) }}</p>
    
    <!-- Conditional content -->
    <div v-if="$i18n.locale === 'en'">
      English specific content
    </div>
  </div>
</template>

<script setup>
// Access i18n in script
const { t, locale, localeRoute } = useI18n()

// Programmatic navigation with locale
const goToAbout = () => {
  navigateTo(localeRoute('/about'))
}

// Dynamic translations
const dynamicMessage = computed(() => {
  return t('hello', { name: user.value?.name || 'Guest' })
})

// SEO with i18n
const { locale } = useI18n()
useHead({
  htmlAttrs: {
    lang: locale
  }
})
</script>
40. What are some useful community modules available for Nuxt 3?
Answer: Essential Modules:

TypeScript
// nuxt.config.ts
export default defineNuxtConfig({
  modules: [
    // Styling & UI
    '@nuxtjs/tailwindcss',
    '@nuxtjs/color-mode',
    '@nuxt/ui',
    '@nuxtjs/google-fonts',
    
    // State Management
    '@pinia/nuxt',
    '@vueuse/nuxt',
    
    // Content & CMS
    '@nuxt/content',
    '@nuxtjs/strapi',
    '@nuxtjs/sanity',
    
    // Authentication
    '@sidebase/nuxt-auth',
    '@nuxtjs/supabase',
    
    // Performance & SEO
    '@nuxt/image',
    '@nuxtjs/robots',
    '@nuxtjs/sitemap',
    'nuxt-simple-sitemap',
    
    // Analytics & Tracking
    '@nuxtjs/google-analytics',
    '@nuxtjs/gtm',
    'nuxt-gtag',
    
    // Development
    '@nuxt/devtools',
    '@nuxtjs/eslint-module',
    
    // Database & API
    '@nuxtjs/prisma',
    '@nuxtjs/axios', // For Nuxt 2 compatibility
    
    // Utilities
    '@nuxtjs/device',
    'nuxt-security',
    '@nuxtjs/robots'
  ]
})
Module Configurations:

TypeScript
// Content module
export default defineNuxtConfig({
  modules: ['@nuxt/content'],
  
  content: {
    highlight: {
      theme: 'github-dark',
      preload: ['typescript', 'javascript', 'vue']
    },
    
    markdown: {
      toc: {
        depth: 3,
        searchDepth: 3
      }
    }
  }
})

// Image optimization
export default defineNuxtConfig({
  modules: ['@nuxt/image'],
  
  image: {
    cloudinary: {
      baseURL: 'https://res.cloudinary.com/demo/image/upload/'
    },
    
    screens: {
      xs: 320,
      sm: 640,
      md: 768,
      lg: 1024,
      xl: 1280,
      xxl: 1536
    }
  }
})

// Authentication
export default defineNuxtConfig({
  modules: ['@sidebase/nuxt-auth'],
  
  auth: {
    baseURL: process.env.AUTH_ORIGIN,
    provider: {
      type: 'authjs'
    }
  }
})
🧪 Scenario-Based Questions
41. If your Nuxt 3 app is loading slowly, how would you debug and fix it?
Answer: Debugging Steps:

TypeScript
// 1. Performance Monitoring
// nuxt.config.ts
export default defineNuxtConfig({
  // Enable debugging
  debug: process.env.NODE_ENV === 'development',
  
  // Bundle analyzer
  build: {
    analyze: true
  },
  
  // Nitro timing
  nitro: {
    timing: true
  }
})

// 2. Network Analysis
<script setup>
// Track component loading times
const startTime = performance.now()

onMounted(() => {
  const endTime = performance.now()
  console.log(`Component loaded in ${endTime - startTime}ms`)
})

// Monitor data fetching
const { data, pending } = await useFetch('/api/slow-endpoint', {
  onRequest({ request }) {
    console.log('Fetching:', request)
  },
  onResponse({ response }) {
    console.log('Response time:', response.headers.get('x-response-time'))
  }
})
</script>

// 3. Code Splitting & Lazy Loading
// pages/heavy-page.vue
<template>
  <div>
    <!-- Lazy load heavy components -->
    <LazyHeavyChart v-if="showChart" />
    
    <!-- Client-only components -->
    <ClientOnly>
      <ExpensiveComponent />
      <template #fallback>
        <div>Loading...</div>
      </template>
    </ClientOnly>
  </div>
</template>

<script setup>
// Lazy load data
const { data: heavyData } = await useLazyFetch('/api/heavy-data')

// Conditional loading
const showChart = ref(false)

// Load chart only when needed
const loadChart = async () => {
  showChart.value = true
}
</script>
Optimization Techniques:

TypeScript
// 4. Image Optimization
<template>
  <NuxtImg
    src="/large-image.jpg"
    sizes="sm:100vw md:50vw lg:25vw"
    loading="lazy"
    placeholder="/placeholder.jpg"
  />
</template>

// 5. Caching Strategy
// server/api/cached-data.get.ts
export default defineCachedEventHandler(async (event) => {
  const data = await expensiveOperation()
  return data
}, {
  maxAge: 60 * 5, // 5 minutes
  group: 'api',
  varies: ['Authorization']
})

// 6. Preloading & Prefetching
<script setup>
// Preload critical routes
preloadRouteComponents('/dashboard')

// Prefetch on hover
const prefetchOnHover = () => {
  preloadRouteComponents('/profile')
}
</script>

// 7. Bundle optimization
// nuxt.config.ts
export default defineNuxtConfig({
  vite: {
    build: {
      rollupOptions: {
        external: ['lodash'], // Externalize heavy dependencies
        output: {
          manualChunks: {
            vendor: ['vue', 'vue-router'],
            utils: ['lodash', 'date-fns']
          }
        }
      }
    }
  }
})
42. How would you build a dashboard with dynamic layouts using Nuxt 3?
Answer:

Vue
<!-- layouts/dashboard.vue -->
<template>
  <div class="min-h-screen bg-gray-50">
    <!-- Header -->
    <header class="bg-white shadow-sm border-b">
      <div class="flex items-center justify-between px-6 py-4">
        <div class="flex items-center space-x-4">
          <button @click="toggleSidebar" class="lg:hidden">
            <Icon name="menu" />
          </button>
          <h1 class="text-xl font-semibold">Dashboard</h1>
        </div>
        
        <div class="flex items-center space-x-4">
          <NotificationDropdown />
          <UserDropdown />
        </div>
      </div>
    </header>
    
    <div class="flex">
      <!-- Sidebar -->
      <aside 
        :class="[
          'bg-white shadow-sm transition-all duration-300',
          sidebarCollapsed ? 'w-16' : 'w-64',
          showMobileSidebar ? 'translate-x-0' : '-translate-x-full lg:translate-x-0'
        ]"
        class="fixed lg:static h-full z-30"
      >
        <DashboardSidebar :collapsed="sidebarCollapsed" />
      </aside>
      
      <!-- Main Content -->
      <main class="flex-1 lg:ml-0" :class="{ 'ml-64': !sidebarCollapsed }">
        <div class="p-6">
          <!-- Breadcrumbs -->
          <DashboardBreadcrumbs />
          
          <!-- Page Content -->
          <div class="mt-6">
            <slot />
          </div>
        </div>
      </main>
    </div>
    
    <!-- Mobile Sidebar Overlay -->
    <div 
      v-if="showMobileSidebar"
      @click="showMobileSidebar = false"
      class="fixed inset-0 bg-black bg-opacity-50 z-20 lg:hidden"
    />
  </div>
</template>

<script setup>
const sidebarCollapsed = useState('dashboard.sidebar.collapsed', () => false)
const showMobileSidebar = ref(false)

const toggleSidebar = () => {
  if (process.client && window.innerWidth < 1024) {
    showMobileSidebar.value = !showMobileSidebar.value
  } else {
    sidebarCollapsed.value = !sidebarCollapsed.value
  }
}

// Close mobile sidebar on route change
const route = useRoute()
watch(() => route.path, () => {
  showMobileSidebar.value = false
})
</script>

<!-- components/DashboardSidebar.vue -->
<template>
  <nav class="h-full flex flex-col">
    <div class="p-4">
      <NuxtLink to="/dashboard" class="flex items-center space-x-3">
        <img src="/logo.png" alt="Logo" class="w-8 h-8">
        <span v-if="!collapsed" class="font-bold text-lg">App</span>
      </NuxtLink>
    </div>
    
    <div class="flex-1 px-3">
      <ul class="space-y-1">
        <li v-for="item in menuItems" :key="item.path">
          <NuxtLink
            :to="item.path"
            :class="[
              'flex items-center px-3 py-2 rounded-lg transition-colors',
              isActive(item.path) 
                ? 'bg-blue-100 text-blue-700' 
                : 'text-gray-700 hover:bg-gray-100'
            ]"
          >
            <Icon :name="item.icon" class="w-5 h-5" />
            <span v-if="!collapsed" class="ml-3">{{ item.label }}</span>
          </NuxtLink>
        </li>
      </ul>
    </div>
  </nav>
</template>

<script setup>
interface Props {
  collapsed: boolean
}

defineProps<Props>()

const route = useRoute()

const menuItems = [
  { path: '/dashboard', label: 'Overview', icon: 'dashboard' },
  { path: '/dashboard/analytics', label: 'Analytics', icon: 'chart' },
  { path: '/dashboard/users', label: 'Users', icon: 'users' },
  { path: '/dashboard/products', label: 'Products', icon: 'package' },
  { path: '/dashboard/orders', label: 'Orders', icon: 'shopping-cart' },
  { path: '/dashboard/settings', label: 'Settings', icon: 'settings' }
]

const isActive = (path: string) => {
  return route.path === path || route.path.startsWith(path + '/')
}
</script>

<!-- pages/dashboard/index.vue -->
<template>
  <div>
    <div class="mb-6">
      <h1 class="text-2xl font-bold text-gray-900">Dashboard Overview</h1>
      <p class="text-gray-600">Welcome back! Here's what's happening.</p>
    </div>
    
    <!-- Stats Grid -->
    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
      <StatsCard
        v-for="stat in stats"
        :key="stat.label"
        :label="stat.label"
        :value="stat.value"
        :change="stat.change"
        :icon="stat.icon"
      />
    </div>
    
    <!-- Charts Row -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
      <ChartCard title="Revenue Trend">
        <LazyLineChart :data="revenueData" />
      </ChartCard>
      
      <ChartCard title="User Growth">
        <LazyBarChart :data="userGrowthData" />
      </ChartCard>
    </div>
    
    <!-- Recent Activity -->
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <div class="lg:col-span-2">
        <RecentOrders />
      </div>
      
      <div>
        <RecentActivity />
      </div>
    </div>
  </div>
</template>

<script setup>
definePageMeta({
  layout: 'dashboard',
  middleware: 'auth'
})

// Fetch dashboard data
const { data: dashboardData } = await useFetch('/api/dashboard/overview')

const stats = computed(() => dashboardData.value?.stats || [])
const revenueData = computed(() => dashboardData.value?.revenueData || [])
const userGrowthData = computed(() => dashboardData.value?.userGrowthData || [])

// Set page title
useHead({
  title: 'Dashboard Overview'
})
</script>

<!-- pages/dashboard/analytics.vue -->
<template>
  <div>
    <div class="mb-6 flex justify-between items-center">
      <div>
        <h1 class="text-2xl font-bold text-gray-900">Analytics</h1>
        <p class="text-gray-600">Detailed insights and metrics</p>
      </div>
      
      <div class="flex space-x-3">
        <DateRangePicker v-model="dateRange" />
        <ExportButton @export="exportData" />
      </div>
    </div>
    
    <!-- Analytics Content -->
    <AnalyticsDashboard :date-range="dateRange" />
  </div>
</template>

<script setup>
definePageMeta({
  layout: 'dashboard',
  middleware: ['auth', 'analytics-access']
})

const dateRange = ref({
  start: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
  end: new Date()
})

const exportData = () => {
  // Export functionality
}

useHead({
  title: 'Analytics Dashboard'
})
</script>
43. How can you build a multi-role auth-based system using Nuxt 3 + Laravel backend?
Answer: Frontend (Nuxt 3) Setup:

TypeScript
// composables/useAuth.ts
interface User {
  id: number
  name: string
  email: string
  roles: string[]
  permissions: string[]
}

interface LoginCredentials {
  email: string
  password: string
}

export const useAuth = () => {
  const user = useState<User | null>('auth.user', () => null)
  const token = useCookie('auth-token', {
    default: () => null,
    httpOnly: true,
    secure: true,
    sameSite: 'strict',
    maxAge: 60 * 60 * 24 * 7 // 7 days
  })
  
  const login = async (credentials: LoginCredentials) => {
    try {
      const response = await $fetch('/api/auth/login', {
        method: 'POST',
        body: credentials,
        baseURL: useRuntimeConfig().public.laravelApiBase
      })
      
      user.value = response.user
      token.value = response.token
      
      return response
    } catch (error) {
      throw error
    }
  }
  
  const logout = async () => {
    try {
      await $fetch('/api/auth/logout', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token.value}`
        },
        baseURL: useRuntimeConfig().public.laravelApiBase
      })
    } finally {
      user.value = null
      token.value = null
      await navigateTo('/login')
    }
  }
  
  const fetchUser = async () => {
    if (!token.value) return
    
    try {
      const userData = await $fetch('/api/auth/user', {
        headers: {
          Authorization: `Bearer ${token.value}`
        },
        baseURL: useRuntimeConfig().public.laravelApiBase
      })
      
      user.value = userData
    } catch (error) {
      // Token might be invalid
      token.value = null
      await navigateTo('/login')
    }
  }
  
  const hasRole = (role: string): boolean => {
    return user.value?.roles?.includes(role) ?? false
  }
  
  const hasAnyRole = (roles: string[]): boolean => {
    return roles.some(role => hasRole(role))
  }
  
  const hasPermission = (permission: string): boolean => {
    return user.value?.permissions?.includes(permission) ?? false
  }
  
  const hasAnyPermission = (permissions: string[]): boolean => {
    return permissions.some(permission => hasPermission(permission))
  }
  
  return {
    user: readonly(user),
    token: readonly(token),
    login,
    logout,
    fetchUser,
    hasRole,
    hasAnyRole,
    hasPermission,
    hasAnyPermission,
    isAuthenticated: computed(() => !!user.value),
    isAdmin: computed(() => hasRole('admin')),
    isModerator: computed(() => hasRole('moderator')),
    isUser: computed(() => hasRole('user'))
  }
}

// middleware/auth.ts
export default defineNuxtRouteMiddleware(() => {
  const { isAuthenticated } = useAuth()
  
  if (!isAuthenticated.value) {
    return navigateTo('/login')
  }
})

// middleware/role.ts
export default defineNuxtRouteMiddleware((to) => {
  const { hasRole, hasAnyRole } = useAuth()
  
  const requiredRole = to.meta.requiresRole as string
  const requiredRoles = to.meta.requiresAnyRole as string[]
  
  if (requiredRole && !hasRole(requiredRole)) {
    throw createError({
      statusCode: 403,
      statusMessage: `Access denied. Required role: ${requiredRole}`
    })
  }
  
  if (requiredRoles && !hasAnyRole(requiredRoles)) {
    throw createError({
      statusCode: 403,
      statusMessage: `Access denied. Required roles: ${requiredRoles.join(', ')}`
    })
  }
})

// middleware/permission.ts
export default defineNuxtRouteMiddleware((to) => {
  const { hasPermission, hasAnyPermission } = useAuth()
  
  const requiredPermission = to.meta.requiresPermission as string
  const requiredPermissions = to.meta.requiresAnyPermission as string[]
  
  if (requiredPermission && !hasPermission(requiredPermission)) {
    throw createError({
      statusCode: 403,
      statusMessage: `Access denied. Required permission: ${requiredPermission}`
    })
  }
  
  if (requiredPermissions && !hasAnyPermission(requiredPermissions)) {
    throw createError({
      statusCode: 403,
      statusMessage: `Access denied. Required permissions: ${requiredPermissions.join(', ')}`
    })
  }
})

// plugins/auth.client.ts
export default defineNuxtPlugin(async () => {
  const { fetchUser, token } = useAuth()
  
  // Restore user session on app load
  if (token.value) {
    await fetchUser()
  }
})

// plugins/api.ts
export default defineNuxtPlugin(() => {
  const { token } = useAuth()
  
  // Global API configuration
  $fetch.create({
    baseURL: useRuntimeConfig().public.laravelApiBase,
    
    onRequest({ options }) {
      if (token.value) {
        options.headers = {
          ...options.headers,
          Authorization: `Bearer ${token.value}`
        }
      }
    },
    
    onResponseError({ response }) {
      if (response.status === 401) {
        // Token expired or invalid
        navigateTo('/login')
      } else if (response.status === 403) {
        // Insufficient permissions
        throw createError({
          statusCode: 403,
          statusMessage: 'Access denied'
        })
      }
    }
  })
})
Page Examples with Role-based Access:

Vue
<!-- pages/admin/index.vue -->
<template>
  <div>
    <h1>Admin Dashboard</h1>
    <p>Welcome to the admin panel</p>
    
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
      <AdminStatsCard title="Total Users" :value="stats.totalUsers" />
      <AdminStatsCard title="Revenue" :value="stats.revenue" />
      <AdminStatsCard title="Orders" :value="stats.orders" />
    </div>
  </div>
</template>

<script setup>
definePageMeta({
  layout: 'admin',
  middleware: ['auth', 'role'],
  requiresRole: 'admin'
})

const { data: stats } = await useFetch('/api/admin/stats')

useHead({
  title: 'Admin Dashboard'
})
</script>

<!-- pages/moderator/posts.vue -->
<template>
  <div>
    <h1>Moderate Posts</h1>
    <PostModerationTable :posts="posts" @approve="approvePost" @reject="rejectPost" />
  </div>
</template>

<script setup>
definePageMeta({
  middleware: ['auth', 'role'],
  requiresAnyRole: ['admin', 'moderator']
})

const { data: posts } = await useFetch('/api/moderator/posts/pending')

const approvePost = async (postId: number) => {
  await $fetch(`/api/moderator/posts/${postId}/approve`, {
    method: 'POST'
  })
  
  // Refresh posts
  await refreshCookie()
}
</script>

<!-- pages/user/profile.vue -->
<template>
  <div>
    <h1>User Profile</h1>
    <UserProfileForm :user="user" @update="updateProfile" />
  </div>
</template>

<script setup>
definePageMeta({
  middleware: ['auth', 'permission'],
  requiresPermission: 'profile.edit'
})

const { user } = useAuth()

const updateProfile = async (data: any) => {
  await $fetch('/api/user/profile', {
    method: 'PUT',
    body: data
  })
}
</script>
Backend (Laravel) Setup:

PHP
<?php
// app/Http/Controllers/AuthController.php

class AuthController extends Controller
{
    public function login(Request $request)
    {
        $credentials = $request->validate([
            'email' => 'required|email',
            'password' => 'required'
        ]);
        
        if (!Auth::attempt($credentials)) {
            return response()->json([
                'message' => 'Invalid credentials'
            ], 401);
        }
        
        $user = Auth::user();
        $token = $user->createToken('auth-token')->plainTextToken;
        
        return response()->json([
            'user' => [
                'id' => $user->id,
                'name' => $user->name,
                'email' => $user->email,
                'roles' => $user->roles->pluck('name'),
                'permissions' => $user->getAllPermissions()->pluck('name')
            ],
            'token' => $token
        ]);
    }
    
    public function logout(Request $request)
    {
        $request->user()->currentAccessToken()->delete();
        
        return response()->json(['message' => 'Logged out successfully']);
    }
    
    public function user(Request $request)
    {
        $user = $request->user();
        
        return response()->json([
            'id' => $user->id,
            'name' => $user->name,
            'email' => $user->email,
            'roles' => $user->roles->pluck('name'),
            'permissions' => $user->getAllPermissions()->pluck('name')
        ]);
    }
}

// app/Http/Middleware/CheckRole.php
class CheckRole
{
    public function handle($request, Closure $next, ...$roles)
    {
        if (!$request->user() || !$request->user()->hasAnyRole($roles)) {
            return response()->json([
                'message' => 'Insufficient permissions'
            ], 403);
        }
        
        return $next($request);
    }
}

// app/Http/Middleware/CheckPermission.php
class CheckPermission
{
    public function handle($request, Closure $next, ...$permissions)
    {
        if (!$request->user() || !$request->user()->hasAnyPermission($permissions)) {
            return response()->json([
                'message' => 'Insufficient permissions'
            ], 403);
        }
        
        return $next($request);
    }
}

// routes/api.php
Route::middleware(['auth:sanctum'])->group(function () {
    Route::get('/auth/user', [AuthController::class, 'user']);
    Route::post('/auth/logout', [AuthController::class, 'logout']);
    
    // Admin routes
    Route::middleware(['role:admin'])->prefix('admin')->group(function () {
        Route::get('/stats', [AdminController::class, 'stats']);
        Route::get('/users', [AdminController::class, 'users']);
    });
    
    // Moderator routes
    Route::middleware(['role:admin,moderator'])->prefix('moderator')->group(function () {
        Route::get('/posts/pending', [ModeratorController::class, 'pendingPosts']);
        Route::post('/posts/{post}/approve', [ModeratorController::class, 'approvePost']);
    });
    
    // User routes
    Route::middleware(['permission:profile.edit'])->group(function () {
        Route::put('/user/profile', [UserController::class, 'updateProfile']);
    });
});
This setup provides a complete multi-role authentication system with granular permission control, seamless integration between Nuxt 3 frontend and Laravel backend, and proper security middleware for protecting routes based on user roles and permissions.

44. How would you persist Vuex or Pinia state in a Nuxt 3 project?
Answer: Pinia State Persistence:

TypeScript
// stores/auth.ts
export const useAuthStore = defineStore('auth', () => {
  const user = ref<User | null>(null)
  const preferences = ref({
    theme: 'light',
    language: 'en',
    notifications: true
  })
  
  const login = async (credentials: LoginCredentials) => {
    // Login logic
    const response = await $fetch('/api/auth/login', {
      method: 'POST',
      body: credentials
    })
    
    user.value = response.user
    return response
  }
  
  const updatePreferences = (newPreferences: Partial<typeof preferences.value>) => {
    preferences.value = { ...preferences.value, ...newPreferences }
  }
  
  return {
    user,
    preferences,
    login,
    updatePreferences
  }
}, {
  // Built-in persistence with @pinia/plugin-persistedstate
  persist: {
    key: 'auth-store',
    storage: persistedState.localStorage,
    
    // Customize what to persist
    paths: ['user', 'preferences'],
    
    // Custom serializer
    serializer: {
      serialize: JSON.stringify,
      deserialize: JSON.parse
    },
    
    // Beforerestore hook
    beforeRestore: (ctx) => {
      console.log('Restoring auth store')
    },
    
    // Afterrestore hook
    afterRestore: (ctx) => {
      console.log('Auth store restored')
    }
  }
})

// stores/cart.ts with advanced persistence
export const useCartStore = defineStore('cart', () => {
  const items = ref<CartItem[]>([])
  const sessionId = ref('')
  const lastUpdated = ref<Date | null>(null)
  
  const addItem = (item: CartItem) => {
    const existingIndex = items.value.findIndex(i => i.id === item.id)
    
    if (existingIndex > -1) {
      items.value[existingIndex].quantity += item.quantity
    } else {
      items.value.push(item)
    }
    
    lastUpdated.value = new Date()
  }
  
  const removeItem = (itemId: string) => {
    const index = items.value.findIndex(item => item.id === itemId)
    if (index > -1) {
      items.value.splice(index, 1)
      lastUpdated.value = new Date()
    }
  }
  
  const clearCart = () => {
    items.value = []
    lastUpdated.value = new Date()
  }
  
  const totalPrice = computed(() => 
    items.value.reduce((total, item) => total + (item.price * item.quantity), 0)
  )
  
  return {
    items,
    sessionId,
    lastUpdated,
    addItem,
    removeItem,
    clearCart,
    totalPrice
  }
}, {
  persist: {
    key: 'shopping-cart',
    storage: persistedState.localStorage,
    
    // Selective persistence
    paths: ['items', 'sessionId'],
    
    // Custom pick/omit
    pick: ['items'],
    
    // Expire after 7 days
    expires: 7 * 24 * 60 * 60 * 1000,
    
    // Migrate old data
    migrate: (persistedState: any, version: number) => {
      if (version < 2) {
        // Migrate from v1 to v2
        persistedState.items = persistedState.items.map((item: any) => ({
          ...item,
          addedAt: new Date().toISOString()
        }))
      }
      return persistedState
    }
  }
})
Manual State Persistence:

TypeScript
// composables/useStatePersistence.ts
export const useStatePersistence = () => {
  const saveToStorage = (key: string, data: any, storage: 'local' | 'session' = 'local') => {
    if (process.client) {
      const storageApi = storage === 'local' ? localStorage : sessionStorage
      
      try {
        const serialized = JSON.stringify({
          data,
          timestamp: Date.now(),
          version: 1
        })
        
        storageApi.setItem(key, serialized)
      } catch (error) {
        console.error('Failed to save to storage:', error)
      }
    }
  }
  
  const loadFromStorage = (key: string, storage: 'local' | 'session' = 'local') => {
    if (process.client) {
      const storageApi = storage === 'local' ? localStorage : sessionStorage
      
      try {
        const item = storageApi.getItem(key)
        if (!item) return null
        
        const parsed = JSON.parse(item)
        
        // Check if data is expired (24 hours)
        const isExpired = Date.now() - parsed.timestamp > 24 * 60 * 60 * 1000
        if (isExpired) {
          storageApi.removeItem(key)
          return null
        }
        
        return parsed.data
      } catch (error) {
        console.error('Failed to load from storage:', error)
        return null
      }
    }
    
    return null
  }
  
  const removeFromStorage = (key: string, storage: 'local' | 'session' = 'local') => {
    if (process.client) {
      const storageApi = storage === 'local' ? localStorage : sessionStorage
      storageApi.removeItem(key)
    }
  }
  
  return {
    saveToStorage,
    loadFromStorage,
    removeFromStorage
  }
}

// stores/settings.ts with manual persistence
export const useSettingsStore = defineStore('settings', () => {
  const { saveToStorage, loadFromStorage } = useStatePersistence()
  
  const settings = ref({
    theme: 'light',
    language: 'en',
    sidebarCollapsed: false,
    notifications: {
      email: true,
      push: false,
      sms: false
    }
  })
  
  // Load settings on store creation
  const loadSettings = () => {
    const savedSettings = loadFromStorage('user-settings')
    if (savedSettings) {
      settings.value = { ...settings.value, ...savedSettings }
    }
  }
  
  // Save settings whenever they change
  const saveSettings = () => {
    saveToStorage('user-settings', settings.value)
  }
  
  const updateSetting = (key: keyof typeof settings.value, value: any) => {
    settings.value[key] = value
    saveSettings()
  }
  
  const resetSettings = () => {
    settings.value = {
      theme: 'light',
      language: 'en',
      sidebarCollapsed: false,
      notifications: {
        email: true,
        push: false,
        sms: false
      }
    }
    saveSettings()
  }
  
  // Auto-save when settings change
  watch(settings, saveSettings, { deep: true })
  
  return {
    settings,
    loadSettings,
    updateSetting,
    resetSettings
  }
})
Server-Side State Synchronization:

TypeScript
// composables/useStateSync.ts
export const useStateSync = () => {
  const syncWithServer = async (storeKey: string, localData: any) => {
    try {
      // Send local state to server
      const response = await $fetch('/api/user/sync-state', {
        method: 'POST',
        body: {
          storeKey,
          data: localData,
          timestamp: Date.now()
        }
      })
      
      // Return server state if it's newer
      if (response.serverTimestamp > localData.timestamp) {
        return response.data
      }
      
      return localData
    } catch (error) {
      console.error('Failed to sync with server:', error)
      return localData
    }
  }
  
  const loadStateFromServer = async (storeKey: string) => {
    try {
      const response = await $fetch(`/api/user/state/${storeKey}`)
      return response.data
    } catch (error) {
      console.error('Failed to load state from server:', error)
      return null
    }
  }
  
  return {
    syncWithServer,
    loadStateFromServer
  }
}

// stores/syncedStore.ts
export const useSyncedStore = defineStore('synced', () => {
  const { syncWithServer, loadStateFromServer } = useStateSync()
  const { isAuthenticated } = useAuth()
  
  const data = ref({
    preferences: {},
    recentItems: [],
    bookmarks: []
  })
  
  const syncState = async () => {
    if (isAuthenticated.value) {
      const syncedData = await syncWithServer('user-data', data.value)
      data.value = syncedData
    }
  }
  
  const loadFromServer = async () => {
    if (isAuthenticated.value) {
      const serverData = await loadStateFromServer('user-data')
      if (serverData) {
        data.value = serverData
      }
    }
  }
  
  // Auto-sync on data changes (debounced)
  const debouncedSync = debounce(syncState, 1000)
  watch(data, debouncedSync, { deep: true })
  
  return {
    data,
    syncState,
    loadFromServer
  }
})
Plugin Setup:

TypeScript
// plugins/pinia-persistence.client.ts
import { createPersistedState } from 'pinia-plugin-persistedstate'

export default defineNuxtPlugin(({ $pinia }) => {
  $pinia.use(createPersistedState({
    storage: localStorage,
    
    // Global configuration
    beforeRestore: (context) => {
      console.log('Before restoring', context.store.$id)
    },
    
    afterRestore: (context) => {
      console.log('After restoring', context.store.$id)
    },
    
    // Custom key generation
    key: (id) => `__persisted__${id}__`,
    
    // Global serializer
    serializer: {
      serialize: (state) => {
        return btoa(JSON.stringify(state))
      },
      deserialize: (value) => {
        return JSON.parse(atob(value))
      }
    }
  }))
})

// plugins/state-hydration.client.ts
export default defineNuxtPlugin(async () => {
  const authStore = useAuthStore()
  const settingsStore = useSettingsStore()
  
  // Hydrate stores on client-side
  if (process.client) {
    settingsStore.loadSettings()
    
    // Load synced data if authenticated
    if (authStore.user) {
      const syncedStore = useSyncedStore()
      await syncedStore.loadFromServer()
    }
  }
})
This comprehensive state persistence setup provides multiple strategies for maintaining state across sessions, including automatic persistence with Pinia plugins, manual storage management, and server synchronization for authenticated users.

45. How do you manage large-scale Nuxt 3 projects with modular architecture?
Answer: Project Structure for Large-Scale Applications:

Code
project/
├── apps/                          # Multiple applications
│   ├── web/                       # Main web app
│   ├── admin/                     # Admin dashboard
│   └── mobile/                    # Mobile app
├── packages/                      # Shared packages
│   ├── ui/                        # UI components library
│   ├── api/                       # API client
│   ├── types/                     # TypeScript types
│   └── utils/                     # Shared utilities
├── modules/                       # Custom Nuxt modules
│   ├── auth/                      # Authentication module
│   ├── analytics/                 # Analytics module
│   └── cms/                       # CMS integration
├── layers/                        # Nuxt layers
│   ├── base/                      # Base layer
│   └── theme/                     # Theme layer
└── shared/                        # Shared configurations
    ├── configs/                   # Shared configs
    └── types/                     # Shared types
Monorepo Setup with Workspaces:

JSON
// package.json (root)
{
  "name": "large-scale-nuxt-app",
  "private": true,
  "workspaces": [
    "apps/*",
    "packages/*",
    "modules/*",
    "layers/*"
  ],
  "scripts": {
    "dev": "turbo run dev",
    "build": "turbo run build",
    "test": "turbo run test",
    "lint": "turbo run lint",
    "type-check": "turbo run type-check"
  },
  "devDependencies": {
    "turbo": "^1.10.0",
    "@nuxt/eslint-config": "^0.2.0",
    "typescript": "^5.0.0"
  }
}

// turbo.json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": [".nuxt/**", ".output/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "lint": {
      "outputs": []
    },
    "test": {
      "dependsOn": ["^build"],
      "outputs": ["coverage/**"]
    }
  }
}
Shared UI Component Library:

TypeScript
// packages/ui/nuxt.config.ts
export default defineNuxtConfig({
  extends: ['@nuxt/ui-pro'],
  
  components: {
    dirs: [
      {
        path: '~/components',
        global: true,
        prefix: 'Ui'
      }
    ]
  },
  
  css: ['~/assets/css/components.css']
})

// packages/ui/components/Button/Button.vue
<template>
  <button
    :class="buttonClasses"
    :disabled="disabled || loading"
    @click="handleClick"
  >
    <Icon v-if="loading" name="spinner" class="animate-spin" />
    <Icon v-else-if="icon" :name="icon" />
    <slot />
  </button>
</template>

<script setup lang="ts">
interface Props {
  variant?: 'primary' | 'secondary' | 'ghost' | 'danger'
  size?: 'sm' | 'md' | 'lg'
  icon?: string
  loading?: boolean
  disabled?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  variant: 'primary',
  size: 'md'
})

const emit = defineEmits<{
  click: [event: MouseEvent]
}>()

const buttonClasses = computed(() => {
  const base = 'inline-flex items-center gap-2 font-medium transition-colors'
  const variants = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300',
    ghost: 'text-gray-700 hover:bg-gray-100',
    danger: 'bg-red-600 text-white hover:bg-red-700'
  }
  const sizes = {
    sm
You said: continue
continue
Copilot said: ```typescript sm: 'px-3 py-1.5
TypeScript
    sm: 'px-3 py-1.5 text-sm rounded-md',
    md: 'px-4 py-2 text-base rounded-lg',
    lg: 'px-6 py-3 text-lg rounded-xl'
  }
  
  return [
    base,
    variants[props.variant],
    sizes[props.size],
    props.disabled && 'opacity-50 cursor-not-allowed'
  ].filter(Boolean).join(' ')
})

const handleClick = (event: MouseEvent) => {
  if (!props.disabled && !props.loading) {
    emit('click', event)
  }
}
</script>

// packages/ui/index.ts
export { default as UiButton } from './components/Button/Button.vue'
export { default as UiCard } from './components/Card/Card.vue'
export { default as UiModal } from './components/Modal/Modal.vue'
export { default as UiTable } from './components/Table/Table.vue'
export { default as UiForm } from './components/Form/Form.vue'

// Export types
export type { ButtonProps } from './components/Button/types'
export type { CardProps } from './components/Card/types'
Feature-Based Module System:

TypeScript
// modules/auth/index.ts
import { defineNuxtModule, addPlugin, addComponent, createResolver } from '@nuxt/kit'

export default defineNuxtModule({
  meta: {
    name: 'auth-module',
    configKey: 'auth'
  },
  
  defaults: {
    providers: ['local'],
    redirects: {
      login: '/login',
      logout: '/',
      home: '/dashboard'
    },
    strategies: {
      local: {
        endpoints: {
          login: { url: '/api/auth/login', method: 'post' },
          logout: { url: '/api/auth/logout', method: 'post' },
          user: { url: '/api/auth/user', method: 'get' }
        }
      }
    }
  },
  
  setup(options, nuxt) {
    const resolver = createResolver(import.meta.url)
    
    // Add composables
    nuxt.hook('imports:dirs', (dirs) => {
      dirs.push(resolver.resolve('./runtime/composables'))
    })
    
    // Add middleware
    nuxt.hook('imports:dirs', (dirs) => {
      dirs.push(resolver.resolve('./runtime/middleware'))
    })
    
    // Add components
    addComponent({
      name: 'AuthLoginForm',
      filePath: resolver.resolve('./runtime/components/LoginForm.vue')
    })
    
    // Add plugin
    addPlugin(resolver.resolve('./runtime/plugin'))
    
    // Add server handlers
    nuxt.hook('nitro:config', (nitroConfig) => {
      nitroConfig.handlers = nitroConfig.handlers || []
      nitroConfig.handlers.push({
        route: '/api/auth/**',
        handler: resolver.resolve('./runtime/server/auth.ts')
      })
    })
    
    // Add runtime config
    nuxt.options.runtimeConfig.auth = options
    nuxt.options.runtimeConfig.public.auth = {
      providers: options.providers,
      redirects: options.redirects
    }
  }
})

// modules/auth/runtime/composables/useAuth.ts
export const useAuth = () => {
  const config = useRuntimeConfig().public.auth
  const user = useState('auth.user', () => null)
  const token = useCookie('auth-token')
  
  const login = async (credentials: any) => {
    const { data } = await $fetch('/api/auth/login', {
      method: 'POST',
      body: credentials
    })
    
    user.value = data.user
    token.value = data.token
    
    await navigateTo(config.redirects.home)
  }
  
  const logout = async () => {
    await $fetch('/api/auth/logout', { method: 'POST' })
    user.value = null
    token.value = null
    await navigateTo(config.redirects.logout)
  }
  
  return {
    user: readonly(user),
    login,
    logout,
    isAuthenticated: computed(() => !!user.value)
  }
}
Nuxt Layers for Shared Functionality:

TypeScript
// layers/base/nuxt.config.ts
export default defineNuxtConfig({
  modules: [
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt',
    '@vueuse/nuxt'
  ],
  
  // Base configuration shared across all apps
  app: {
    head: {
      meta: [
        { charset: 'utf-8' },
        { name: 'viewport', content: 'width=device-width, initial-scale=1' }
      ]
    }
  },
  
  css: ['~/assets/css/base.css'],
  
  runtimeConfig: {
    public: {
      appVersion: process.env.npm_package_version
    }
  }
})

// layers/base/composables/useApi.ts
export const useApi = () => {
  const config = useRuntimeConfig()
  
  const api = $fetch.create({
    baseURL: config.public.apiBase,
    
    onRequest({ options }) {
      const token = useCookie('auth-token')
      if (token.value) {
        options.headers = {
          ...options.headers,
          Authorization: `Bearer ${token.value}`
        }
      }
    }
  })
  
  return api
}

// layers/theme/nuxt.config.ts
export default defineNuxtConfig({
  extends: ['../base'],
  
  // Theme-specific configuration
  tailwindcss: {
    config: {
      theme: {
        extend: {
          colors: {
            primary: {
              50: '#eff6ff',
              500: '#3b82f6',
              900: '#1e3a8a'
            }
          }
        }
      }
    }
  }
})
Main Application Configuration:

TypeScript
// apps/web/nuxt.config.ts
export default defineNuxtConfig({
  extends: ['../../layers/theme'],
  
  modules: [
    // Local modules
    '../../modules/auth',
    '../../modules/analytics',
    
    // Package modules
    '../../packages/ui/nuxt.config'
  ],
  
  // App-specific configuration
  auth: {
    providers: ['local', 'google', 'github'],
    redirects: {
      login: '/auth/login',
      home: '/dashboard'
    }
  },
  
  runtimeConfig: {
    public: {
      appName: 'Main Web App',
      apiBase: process.env.API_BASE_URL
    }
  }
})

// apps/admin/nuxt.config.ts
export default defineNuxtConfig({
  extends: ['../../layers/theme'],
  
  modules: [
    '../../modules/auth',
    '../../packages/ui/nuxt.config'
  ],
  
  // Admin-specific configuration
  auth: {
    providers: ['local'],
    redirects: {
      login: '/admin/login',
      home: '/admin/dashboard'
    }
  },
  
  ssr: false, // Admin as SPA
  
  runtimeConfig: {
    public: {
      appName: 'Admin Dashboard',
      apiBase: process.env.ADMIN_API_BASE_URL
    }
  }
})
Domain-Driven Design Structure:

Code
apps/web/
├── domains/                       # Business domains
│   ├── user/                      # User domain
│   │   ├── components/           # Domain components
│   │   ├── composables/          # Domain logic
│   │   ├── pages/               # Domain pages
│   │   ├── stores/              # Domain state
│   │   └── types/               # Domain types
│   ├── product/                   # Product domain
│   │   ├── components/
│   │   ├── composables/
│   │   ├── pages/
│   │   ├── stores/
│   │   └── types/
│   └── order/                     # Order domain
│       ├── components/
│       ├── composables/
│       ├── pages/
│       ├── stores/
│       └── types/
├── shared/                        # Shared app logic
│   ├── components/               # Shared components
│   ├── composables/              # Shared composables
│   ├── layouts/                  # App layouts
│   ├── middleware/               # App middleware
│   └── utils/                    # App utilities
└── pages/                         # Route pages (thin layer)
    ├── users/
    │   └── [...slug].vue         # Delegates to user domain
    ├── products/
    │   └── [...slug].vue         # Delegates to product domain
    └── orders/
        └── [...slug].vue         # Delegates to order domain
Domain Implementation Example:

TypeScript
// apps/web/domains/user/composables/useUser.ts
export const useUser = () => {
  const userStore = useUserStore()
  const api = useApi()
  
  const fetchUser = async (id: string) => {
    const user = await api(`/users/${id}`)
    userStore.setUser(user)
    return user
  }
  
  const updateUser = async (id: string, data: Partial<User>) => {
    const updatedUser = await api(`/users/${id}`, {
      method: 'PUT',
      body: data
    })
    
    userStore.updateUser(updatedUser)
    return updatedUser
  }
  
  const deleteUser = async (id: string) => {
    await api(`/users/${id}`, { method: 'DELETE' })
    userStore.removeUser(id)
  }
  
  return {
    user: computed(() => userStore.currentUser),
    users: computed(() => userStore.users),
    fetchUser,
    updateUser,
    deleteUser
  }
}

// apps/web/domains/user/stores/userStore.ts
export const useUserStore = defineStore('user', () => {
  const users = ref<User[]>([])
  const currentUser = ref<User | null>(null)
  
  const setUser = (user: User) => {
    currentUser.value = user
  }
  
  const setUsers = (userList: User[]) => {
    users.value = userList
  }
  
  const updateUser = (updatedUser: User) => {
    const index = users.value.findIndex(u => u.id === updatedUser.id)
    if (index > -1) {
      users.value[index] = updatedUser
    }
    
    if (currentUser.value?.id === updatedUser.id) {
      currentUser.value = updatedUser
    }
  }
  
  const removeUser = (userId: string) => {
    users.value = users.value.filter(u => u.id !== userId)
    
    if (currentUser.value?.id === userId) {
      currentUser.value = null
    }
  }
  
  return {
    users,
    currentUser,
    setUser,
    setUsers,
    updateUser,
    removeUser
  }
})

// apps/web/pages/users/[...slug].vue
<template>
  <div>
    <UserDomainRouter />
  </div>
</template>

<script setup>
// Thin routing layer - delegates to domain
definePageMeta({
  layout: 'default'
})
</script>

// apps/web/domains/user/components/UserDomainRouter.vue
<template>
  <div>
    <div v-if="isListRoute">
      <UserList />
    </div>
    
    <div v-else-if="isDetailRoute">
      <UserDetail :user-id="userId" />
    </div>
    
    <div v-else-if="isEditRoute">
      <UserEdit :user-id="userId" />
    </div>
    
    <div v-else>
      <UserNotFound />
    </div>
  </div>
</template>

<script setup>
const route = useRoute()
const slug = route.params.slug as string[]

const isListRoute = computed(() => !slug || slug.length === 0)
const isDetailRoute = computed(() => slug?.length === 1 && slug[0] !== 'edit')
const isEditRoute = computed(() => slug?.length === 2 && slug[1] === 'edit')
const userId = computed(() => slug?.[0])
</script>
Testing Strategy for Large Projects:

TypeScript
// shared/testing/setup.ts
import { vi } from 'vitest'
import { createTestingPinia } from '@pinia/testing'

export const createTestUtils = () => {
  const pinia = createTestingPinia({
    createSpy: vi.fn
  })
  
  const mockApi = vi.fn()
  
  const mockNuxtApp = () => {
    vi.mock('#app', () => ({
      useNuxtApp: () => ({
        $api: mockApi
      }),
      useState: vi.fn(() => ref(null)),
      navigateTo: vi.fn(),
      useCookie: vi.fn(() => ref(null))
    }))
  }
  
  return {
    pinia,
    mockApi,
    mockNuxtApp
  }
}

// domains/user/composables/__tests__/useUser.test.ts
import { describe, it, expect, beforeEach } from 'vitest'
import { createTestUtils } from '~/shared/testing/setup'
import { useUser } from '../useUser'

describe('useUser', () => {
  const { mockApi, mockNuxtApp } = createTestUtils()
  
  beforeEach(() => {
    mockNuxtApp()
  })
  
  it('should fetch user successfully', async () => {
    const mockUser = { id: '1', name: 'John Doe' }
    mockApi.mockResolvedValue(mockUser)
    
    const { fetchUser } = useUser()
    const result = await fetchUser('1')
    
    expect(mockApi).toHaveBeenCalledWith('/users/1')
    expect(result).toEqual(mockUser)
  })
})
Build and Deployment Scripts:

TypeScript
// scripts/build.ts
import { execSync } from 'child_process'

const apps = ['web', 'admin']
const environment = process.env.NODE_ENV || 'production'

console.log(`Building for ${environment}...`)

for (const app of apps) {
  console.log(`Building ${app}...`)
  
  try {
    execSync(`cd apps/${app} && npm run build`, {
      stdio: 'inherit',
      env: {
        ...process.env,
        NODE_ENV: environment
      }
    })
    
    console.log(`✅ ${app} built successfully`)
  } catch (error) {
    console.error(`❌ Failed to build ${app}:`, error)
    process.exit(1)
  }
}

console.log('🎉 All apps built successfully!')

// docker/docker-compose.yml
version: '3.8'

services:
  web:
    build:
      context: .
      dockerfile: docker/web.Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - API_BASE_URL=${API_BASE_URL}
    depends_on:
      - api
      
  admin:
    build:
      context: .
      dockerfile: docker/admin.Dockerfile
    ports:
      - "3001:3000"
    environment:
      - NODE_ENV=production
      - ADMIN_API_BASE_URL=${ADMIN_API_BASE_URL}
    depends_on:
      - api
      
  api:
    image: node:18-alpine
    # API configuration