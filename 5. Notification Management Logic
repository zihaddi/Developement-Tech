# Notifications System Architecture

## 📌 Core Features
- **Hybrid Delivery**: DB persistence + real-time push
- **Multi-channel**: In-app, WebSocket, Email/SMS
- **Mark-as-read** functionality

## 🗂️ Notification Types
| Type                | Example Use Case          | Persistence       | Tech Stack        |
|---------------------|---------------------------|-------------------|-------------------|
| Database            | Order confirmations       | Until read        | Laravel DB        |
| Real-Time (WebSocket)| Live chat messages        | Ephemeral         | Pusher/Laravel Echo |
| Email/SMS           | Order receipts            | External storage  | Mailgun/Twilio    |

## 🔄 System Flow
```mermaid
graph TD
    A[Event Trigger] --> B(Laravel Notification)
    B --> C{Channels}
    C --> D[Database]
    C --> E[WebSocket]
    C --> F[Email/SMS]
    D --> G[Nuxt.js API Fetch]
    E --> H[Live UI Update]



🛠️ Implementation Guide

Backend (Laravel)

1. Create Notification Class

php artisan make:notification OrderSuccessNotification


2. Configure Channels (OrderSuccessNotification.php)

    public function via($notifiable)
    {
        return ['database', 'broadcast', 'mail']; // Channels
    }
    
    public function toDatabase($notifiable)
    {
        return [
            'order_id' => $this->order->id,
            'message' => "Order #{$this->order->id} confirmed",
            'icon' => 'fa-check-circle' // Frontend display
        ];
    }
    
    public function toBroadcast($notifiable)
    {
        return new BroadcastMessage($this->toArray($notifiable));
    }

3. Trigger Notification

    $user->notify(new OrderSuccessNotification($order));
    
    // For multiple recipients
    Notification::send($users, new OrderSuccessNotification($order));



Frontend (Nuxt.js)

1. Install Dependencies

npm install laravel-echo pusher-js @nuxtjs/axios

2. Configure Echo (plugins/echo.js)

import Echo from 'laravel-echo'
import Pusher from 'pusher-js'

export default defineNuxtPlugin(() => {
  const echo = new Echo({
    broadcaster: 'pusher',
    key: process.env.PUSHER_APP_KEY,
    cluster: process.env.PUSHER_APP_CLUSTER,
    forceTLS: true
  })

  return {
    provide: { echo }
  }
})


3. Fetch & Listen (composables/useNotifications.js)

export const useNotifications = () => {
  const notifications = ref([])

  // Fetch initial notifications
  const fetch = async () => {
    const { data } = await useFetch('/api/notifications')
    notifications.value = data.value
  }

  // Real-time listener
  const listen = (userId) => {
    const { $echo } = useNuxtApp()
    
    $echo.private(`user.${userId}`)
      .listen('.NewNotification', (data) => {
        notifications.value.unshift(data)
      })
  }

  return { notifications, fetch, listen }
}

4. Component Usage (components/NotificationBell.vue)

<script setup>
const { notifications, fetch, listen } = useNotifications()
const user = useAuthUser() // Your auth system

onMounted(async () => {
  await fetch()
  listen(user.value.id)
})
</script>

<template>
  <div v-for="notif in notifications" :key="notif.id">
    <Icon :name="notif.icon"/> {{ notif.message }}
  </div>
</template>


Database Migration

Schema::create('notifications', function (Blueprint $table) {
    $table->uuid('id')->primary();
    $table->string('type'); // Class path
    $table->morphs('notifiable'); // User/Model relation
    $table->json('data'); // Custom payload
    $table->timestamp('read_at')->nullable();
    $table->timestamps();
    
    $table->index('notifiable_id'); // Optimize queries
});


Real-Time Event (Optional)

1. Create Event

php artisan make:event NewNotificationEvent

2. Configure Broadcasting (NewNotificationEvent.php)

class NewNotificationEvent implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets;

    public function __construct(
        public Notification $notification
    ) {}

    public function broadcastOn()
    {
        return new PrivateChannel(
            'user.' . $this->notification->notifiable_id
        );
    }

    public function broadcastAs()
    {
        return 'NewNotification';
    }
}

3. Trigger Event

// Add to your Notification class
public function toBroadcast($notifiable)
{
    return new NewNotificationEvent($this);
}

Environment Variables (.env)

# Pusher Config
PUSHER_APP_ID=your_id
PUSHER_APP_KEY=your_key
PUSHER_APP_SECRET=your_secret
PUSHER_APP_CLUSTER=mt1

# Laravel Config
BROADCAST_DRIVER=pusher
QUEUE_CONNECTION=database # For delayed emails

Testing Tips

// PHPUnit test case
public function test_notification_sent()
{
    Notification::fake();
    
    $order = Order::factory()->create();
    $user = User::factory()->create();
    
    $user->notify(new OrderSuccessNotification($order));
    
    Notification::assertSentTo(
        $user,
        OrderSuccessNotification::class
    );
}

// Jest test for frontend
test('receives real-time notification', async () => {
  const mockData = { message: "Test", icon: "fa-bell" };
  window.Echo = { private: jest.fn().mockReturnThis(), listen: jest.fn() };
  
  const { listen } = useNotifications();
  listen(1);
  
  expect(window.Echo.private).toHaveBeenCalledWith('user.1');
});

    
